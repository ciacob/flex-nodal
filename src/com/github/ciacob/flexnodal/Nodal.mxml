<?xml version="1.0" encoding="utf-8"?>
<s:Group xmlns:fx="http://ns.adobe.com/mxml/2009"
    xmlns:s="library://ns.adobe.com/flex/spark"
    xmlns:mx="library://ns.adobe.com/flex/mx"
    xmlns:local="com.github.ciacob.flexnodal.*"
    xmlns:components="com.github.ciacob.flexnodal.components.*"
    preinitialize="_onPreinitialize()">

    <fx:Metadata>
        [Style(name="chartStyle", type="String", inherit="false")]
    </fx:Metadata>

    <fx:Script>
        <![CDATA[
            import com.github.ciacob.flexnodal.utils.InstanceFactory;
            import mx.core.UIComponent;
            import com.github.ciacob.flexnodal.events.NodalEvent;
            import mx.collections.ArrayCollection;
            import com.github.ciacob.flexnodal.components.LineChartLayer;
            import com.github.ciacob.flexnodal.utils.Helpers;
            import com.github.ciacob.flexnodal.utils.DefaultStyles;
            import spark.components.Group;
            import mx.styles.CSSStyleDeclaration;
            import mx.styles.IStyleManager2;
            
            // Helper style manager for reading styles before they actually get
            // applied to our component.
            private static var _sm:IStyleManager2 = StyleManager.getStyleManager(null);
            
            // Bindable storage for the chart being currently on top of the
            // others, receiving editing actions and dispatching events.
            [Bindable]
            private var _currentChart:LineChartLayer;
            
            // Bindable storage for the currently selected node of the current
            // chart layer (`null` if not applicable).
            [Bindable]
            private var _selectedNode:Array;
            
            // Storage for the extracted value of the `defaultAlpha` chart style.
            // Defaults to `DefaultStyles.DEFAULT_CHART_ALPHA`, unless overridden.
            // Charts display using default alpha unless selected, in which case
            // they display at alpha `1`.
            private var _defaultAlpha:Number = DefaultStyles.DEFAULT_CHART_ALPHA;
            
            /**
             * Storage for the provider of "drawables", UIComponent instances used
             * to draw chart markers in.
             */
            private const _drawablesFactory:InstanceFactory = new InstanceFactory(
                    UIComponent,
                    _initDrawable,
                    _purgeDrawable);
            
            /**
             * Storage for the providers of "charts", LineChartLayer instances used
             * to display and edit line charts.
             */
            private const _chartsFactory:InstanceFactory = new InstanceFactory(
                    LineChartLayer,
                    _initChart,
                    _purgeChart
                );
            
            // ---------------------------
            // The `dataProvider` property
            // ---------------------------
            
            // Storage for the `_dataProvider` property.
            private var _dataProvider:ArrayCollection;
            
            // Flag to raise when the `_dataProvider` property has been
            // externally changed.
            private var _dataProviderChanged:Boolean;
            
            /**
             * Returns the current data provider of this component.
             */
            public function get dataProvider():ArrayCollection {
                return _dataProvider;
            }
            
            /**
             * Sets or replaces the data provider of this component.
             */
            [Bindable]
            public function set dataProvider(value:ArrayCollection):void {
                if (value !== _dataProvider) {
                    _dataProvider = value;
                    _dataProviderChanged = true;
                    invalidateProperties();
                }
            }
            
            /**
             * Overridden to update layers as needed.
             */
            override protected function commitProperties():void {
                super.commitProperties();
                if (_dataProviderChanged) {
                    _dataProviderChanged = false;
                    _provisionChartLayers(_dataProvider, chartLayers);
                    _populateChartLayers(_dataProvider);
                    _styleChartLayers();
            
                    // Automatically set as `current` the last chart added.
                    const topChart:LineChartLayer = (chartLayers.numElements > 0) ?
                        chartLayers.getElementAt(chartLayers.numElements - 1) as LineChartLayer : null;
                    _setCurrentChart(topChart);
            
                    invalidateDisplayList();
                }
            }
            
            /**
             * Function to be executed against every "drawable" released by the
             * `_drawablesFactory`.
             */
            private function _initDrawable(drawable:UIComponent):void {
                drawable.doubleClickEnabled = true;
                drawable.useHandCursor = true;
                drawable.buttonMode = true;
            }
            
            /**
             * Function to be executed against every decommissioned "drawable"
             * sent back to the `_drawablesFactory` for recycling.
             */
            private function _purgeDrawable(drawable:UIComponent):void {
                drawable.graphics.clear();
                drawable.x = drawable.y = 0;
            }
            
            /**
             * Function to be executed against every "chart" released by the
             * `_chartsFactory`.
             */
            private function _initChart(chart:LineChartLayer):void {
                if (!chart || !_drawablesFactory) {
                    return;
                }
            
                chart.percentWidth = 100;
                chart.percentHeight = 100;
                if (!chart.markersFactory) {
                    chart.markersFactory = _drawablesFactory;
                }
                chart.addEventListener(NodalEvent.LAYER_CLICK, _onLayerClick);
            }
            
            /**
             * Function to be executed against every decommissioned "chart"
             * sent back to the `_chartsFactory` for recycling.
             */
            private function _purgeChart(chart:LineChartLayer):void {
                chart.values = null;
                _unwireChart(chart);
                chart.removeEventListener(NodalEvent.LAYER_CLICK, _onLayerClick);
            }
            
            /**
             * Ensures the `chartLayers` container contains the correct number of
             * charts.
             */
            private function _provisionChartLayers(_dataProvider:ArrayCollection, container:Group):void {
                if (!_chartsFactory || !dataProvider) {
                    return;
                }
                const numCharts:uint = dataProvider.length;
            
                // Append
                while (container.numElements < numCharts) {
                    const chartToAdd:LineChartLayer = LineChartLayer(_chartsFactory.give());
                    _wireChart(chartToAdd);
                    container.addElement(chartToAdd);
                }
            
                // Trim
                while (container.numElements > numCharts) {
                    const chartToRemove:LineChartLayer = LineChartLayer(container.getElementAt(container.numElements - 1));
                    _unwireChart(chartToRemove);
                    container.removeElement(chartToRemove);
                    _chartsFactory.takeBack(chartToRemove);
                }
            
            }
            
            /**
             * Respectively distributes the chart values available in the data provider
             * to the available charts.
             */
            private function _populateChartLayers(_dataProvider:ArrayCollection):void {
                if (!_dataProvider || !chartLayers) {
                    return;
                }
            
                for (var i:int = 0; i < dataProvider.length; i++) {
                    const chartName:String = dataProvider[i] ? dataProvider[i].name : "Chart " + i;
                    const chartValues:Array = dataProvider[i] ? dataProvider[i].values : null;
                    const chart:LineChartLayer = chartLayers.getElementAt(i) as LineChartLayer;
                    if (chart) {
                        chart.layerName = chartName;
                        chart.values = chartValues;
                    }
                }
            }
            
            /**
             * Compiles a set of colors for each provisioned chart layer, based on a
             * provided base color. Passes on common styles, such as padding or line
             * thickness. Sets compiled styles to each chart, respectively.
             */
            private function _styleChartLayers():void {
                if (!chartLayers || !chartLayers.numElements) {
                    return;
                }
            
                // Read styles declaration.
                const chartStyleName:* = getStyle('chartStyle');
                if (chartStyleName === undefined) {
                    return;
                }
                var chartStyleDecl:CSSStyleDeclaration = _sm.getStyleDeclaration('.' + chartStyleName);
                if (!chartStyleDecl) {
                    return;
                }
            
                // Read styles.
                const $g:Function = Helpers.$getStyle;
                const $h:Function = Helpers.getHue;
                const padding:uint = $g(chartStyleDecl, 'padding', DefaultStyles.DEFAULT_PADDING);
                const lineThickness:uint = $g(chartStyleDecl, 'lineThickness', DefaultStyles.DEFAULT_LINE_THICKNESS);
                const baseColor:uint = $g(chartStyleDecl, 'lineColor', DefaultStyles.DEFAULT_LINE_COLOR);
                const baseColorOver:uint = $g(chartStyleDecl, 'lineColorOver', DefaultStyles.DEFAULT_LINE_COLOR_OVER);
                const baseColorSelected:uint = $g(chartStyleDecl, 'lineColorSelected', DefaultStyles.DEFAULT_LINE_COLOR_SELECTED);
                const baseColorAnchor:uint = $g(chartStyleDecl, 'lineColorAnchor', DefaultStyles.DEFAULT_LINE_COLOR_ANCHOR);
                _defaultAlpha = $g(chartStyleDecl, 'defaultAlpha', DefaultStyles.DEFAULT_CHART_ALPHA);
            
                // Set styles on each available chart. Also initialize chart alpha.
                for (var i:int; i < chartLayers.numElements; i++) {
                    const hueFactor:Number = i / chartLayers.numElements;
                    const chart:LineChartLayer = chartLayers.getElementAt(i) as LineChartLayer;
                    if (!chart) {
                        continue;
                    }
                    const $s:Function = chart.setStyle;
                    $s('padding', padding);
                    $s('lineThickness', lineThickness);
                    $s('lineColor', $h(baseColor, hueFactor));
                    $s('lineColorOver', $h(baseColorOver, hueFactor));
                    $s('lineColorSelected', $h(baseColorSelected, hueFactor));
                    $s('lineColorAnchor', $h(baseColorAnchor, hueFactor));
                    chart.alpha = _defaultAlpha;
                }
            }
            
            /**
             * Sets given `chart` as current, hooking it up for event listeners, and also
             * subjecting it to external edit actions, such as deleting the selected nodes.
             */
            private function _setCurrentChart(chart:LineChartLayer):void {
            
                if (!chartLayers || !chartLayers.numElements || chart === _currentChart) {
                    return;
                }
            
                if (_currentChart) {
                    _unwireChart(_currentChart);
                    _currentChart.clearSelection();
                    _currentChart.alpha = _defaultAlpha;
                    _selectedNode = null;
                }
                if (chart) {
                    _currentChart = chart;
                    _wireChart(chart);
                    chart.alpha = 1;
                    chartLayers.setElementIndex(chart, chartLayers.numElements - 1);
                }
            }
            
            /**
             * Removes any event listeners from given chart.
             */
            private function _unwireChart(chart:LineChartLayer):void {
                if (!chart) {
                    return;
                }
            
                chart.removeEventListener(NodalEvent.SELECTION_CHANGE, _onSelectionChanged);
                chart.removeEventListener(NodalEvent.NODES_CHANGE, _onNodesChanged);
            }
            
            /**
             * Adds needed event listeners to given chart.
             */
            private function _wireChart(chart:LineChartLayer):void {
                if (!chart) {
                    return;
                }
            
                chart.addEventListener(NodalEvent.SELECTION_CHANGE, _onSelectionChanged);
                chart.addEventListener(NodalEvent.NODES_CHANGE, _onNodesChanged);
            }
            
            /**
             * Listener. Executed when at the beginning of the component initialization sequence.
             * The component is in a very raw state when this event is dispatched, i.e.,
             * the internal children have not yet been created.
             */
            private function _onPreinitialize():void {
            
            }
            
            /**
             * Listener. Executed when the current chart layer dispatched a `selectionChange`
             * event.
             */
            private function _onSelectionChanged(event:NodalEvent):void {
                _selectedNode = event.payload ? event.payload.selectedNode : null;
            }
            
            /**
             * Listener. Executed when the current chart layer dispatched a `nodesChange`
             * event.
             */
            private function _onNodesChanged(event:NodalEvent):void {
                if (!dataProvider || !chartLayers || !chartLayers.numElements) {
                    return;
                }
                const chart:LineChartLayer = event.target as LineChartLayer;
                if (!chart) {
                    return;
                }
                const chartIdx:int = chartLayers.getElementIndex(chart);
                if (chartIdx === -1) {
                    return;
                }
            
                const dataset:Object = chartIdx < dataProvider.length ? dataProvider[chartIdx] : null;
                if (!dataset) {
                    return;
                }
            
                dataset.values = chart.values;
            
                // Broadcast change. The updated set of values can be retrieved via the `dataProvider`
                // accessor and the `chartIndex` provided by the `NodalEvent.CHART_DATA_CHANGE` event payload.
                dispatchEvent(new NodalEvent(NodalEvent.CHART_DATA_CHANGE, {chartIndex: chartIdx, changedProp: 'values'}));
            
                trace('==> chart values:', chart.values ? '[' + chart.values.join('] [') + ']' : 'NULL');
            }
            
            /**
             * Listener. Dispatched when the current chart layer dispatched a `layerClick`
             * event.
             */
            private function _onLayerClick(event:NodalEvent):void {
                const chart:LineChartLayer = event.target as LineChartLayer;
                if (!chart) {
                    return;
                }
                _setCurrentChart(chart);
                trace('~~~> layer clicked:', event.payload, event.target);
            }
        ]]>
    </fx:Script>

    <!-- Main container -->
    <s:VGroup width="100%" height="100%"
        horizontalAlign="center">

        <!-- The stack of layers (background and chart lines). -->
        <s:Group id="layersStack"
            width="100%" height="100%">

            <!-- Common background for all charts. -->
            <components:BackgroundChartLayer
                id="chartsBg"
                width="100%" height="100%"
                />

            <!-- Container for all chart layers -->
            <s:Group id="chartLayers"
                width="100%" height="100%"/>

        </s:Group>
    </s:VGroup>

</s:Group>
