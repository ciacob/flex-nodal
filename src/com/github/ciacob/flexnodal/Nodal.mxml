<?xml version="1.0" encoding="utf-8"?>
<s:Group xmlns:fx="http://ns.adobe.com/mxml/2009"
    xmlns:s="library://ns.adobe.com/flex/spark"
    xmlns:mx="library://ns.adobe.com/flex/mx"
    xmlns:local="com.github.ciacob.flexnodal.*"
    xmlns:components="com.github.ciacob.flexnodal.components.*"
    preinitialize="_onPreinitialize()">

    <fx:Metadata>
        [Style(name="chartStyle", type="String", inherit="false")]
        
        [Event(name="selectionChange", type="com.github.ciacob.flexnodal.events.NodalEvent")]
        [Event(name="chartDataChange", type="com.github.ciacob.flexnodal.events.NodalEvent")]
        [Event(name="chartActivation", type="com.github.ciacob.flexnodal.events.NodalEvent")]
    </fx:Metadata>

    <fx:Script>
        <![CDATA[
            import com.github.ciacob.flexnodal.utils.InstanceFactory;
            import mx.core.UIComponent;
            import com.github.ciacob.flexnodal.events.NodalEvent;
            import mx.collections.ArrayCollection;
            import com.github.ciacob.flexnodal.components.LineChartLayer;
            import com.github.ciacob.flexnodal.utils.Helpers;
            import com.github.ciacob.flexnodal.utils.DefaultStyles;
            import spark.components.Group;
            import mx.styles.CSSStyleDeclaration;
            import mx.styles.IStyleManager2;
            import com.github.ciacob.flexnodal.Nodal;
            import mx.events.CollectionEvent;
            import spark.filters.DropShadowFilter;
            
            /**
             * Overridable, global `DropShadowFilter` instance to be used underneath the active
             * chart line. Set to `null` to disable.
             */
            public static var ACTIVE_CHART_SHADOW:DropShadowFilter = new DropShadowFilter(0, 0, 0, 0.4, 8, 8);
            
            // Helper style manager for reading styles before they actually get
            // applied to our component.
            private static var _sm:IStyleManager2 = StyleManager.getStyleManager(null);
            
            // Storage for the extracted value of the `defaultAlpha` chart style.
            // Defaults to `DefaultStyles.DEFAULT_CHART_ALPHA`, unless overridden.
            // Charts display using default alpha unless selected, in which case
            // they display at alpha `1`.
            private var _defaultAlpha:Number = DefaultStyles.DEFAULT_CHART_ALPHA;

            // Flag to raise when the component has been styled externally. Attempts to
            // check costly styling operations in check.
            private var _stylesChanged : Boolean = true;
            
            /**
             * Storage for the provider of "drawables", UIComponent instances used
             * to draw chart markers in.
             */
            private const _drawablesFactory:InstanceFactory = new InstanceFactory(
                    UIComponent,
                    _initDrawable,
                    _purgeDrawable);
            
            /**
             * Storage for the provider of "charts", LineChartLayer instances used
             * to display and edit line charts.
             */
            private const _chartsFactory:InstanceFactory = new InstanceFactory(
                    LineChartLayer,
                    _initChart,
                    _purgeChart
                );
            
            // ---------------------------
            // The `dataProvider` property
            // ---------------------------
            
            // Storage for the `dataProvider` property.
            private var _dataProvider:ArrayCollection;
            
            // Flag to raise when the `dataProvider` property has been
            // externally changed.
            private var _dataProviderChanged:Boolean;
            
            /**
             * Returns the current data provider of this component.
             * The data provider defines the chart lines to display and
             * edit.
             */
            public function get dataProvider():ArrayCollection {
                return _dataProvider;
            }
            
            /**
             * Sets or replaces the data provider of this component.
             */
            [Bindable]
            public function set dataProvider(value:ArrayCollection):void {
                if (_dataProvider) {
                    _unwireProvider(_dataProvider);
                    _deactivateChart(_activeChart);
                    _activeChart = null;
                }
            
                _dataProvider = value;
                if (_dataProvider) {
                    _wireProvider(_dataProvider);
                }
            
                _dataProviderChanged = true;
                invalidateProperties();
            }
            
            // -------------------------------
            // The `gridDataProvider` property
            // -------------------------------
            
            // Storage for the `gridDataProvider` property.
            private var _gridDataProvider:ArrayCollection;
            
            // Flag to raise when the `gridDataProvider` property has been
            // externally changed.
            private var _gridDataProviderChanged:Boolean;
            
            /**
             * The data provider currently assigned to this component’s grid.
             *
             * This collection supplies the grid segmentation drawn beneath
             * the line charts, giving visual context for interpreting chart
             * values.
             */
            public function get gridDataProvider():ArrayCollection {
                return _gridDataProvider;
            }
            
            /**
             * Assigns a new data provider for the grid.
             *
             * Setting this property marks the component’s grid data as
             * changed and schedules a commit via `invalidateProperties()`.
             */
            public function set gridDataProvider(value:ArrayCollection):void {
                if (value !== _gridDataProvider) {
                    _gridDataProvider = value;
                    _gridDataProviderChanged = true;
                    invalidateProperties();
                }
            }
            
            // ----------------------------
            // The `operatingMode` property
            // ----------------------------
            public static const READONLY:int = -1;
            public static const NORMAL:int = 0;
            public static const EXCLUSIVE:int = 1;
            public static const ISOLATED:int = 2;
            
            // Storage for the `operatingMode` property
            private var _operatingMode:int = NORMAL;
            
            // Flag we raise when the `operatingMode` property has been externally
            // changed.
            private var _operatingModeChanged:Boolean;
            
            /**
             * Returns the current operating mode for this component. Returned value
             * is one of the `READONLY`, `NORMAL`, `EXCLUSIVE` or `ISOLATED` constants defined by
             * this class.
             *
             * READONLY prevents editing of any chart, including the active one. No
             * nodes are displayed, thus, no selection or manipulation is possible.
             *
             * NORMAL allows immediate access to all charts via clicking their lines.
             * The active chart is fully opaque while the others are semi-transparent.
             * Both active and inactive charts display selectable and draggable nodes.
             *
             * EXCLUSIVE allows access to only the active chart, but other charts can
             * still be accessed by activating them programmatically, via setting
             * `activeChartItem`. Inactive charts do not display nodes, and clicking
             * their lines does not make them active. Useful when user needs to focus on
             * editing the active chart, while still maintaining context awareness.
             *
             * ISOLATED only displays the active chart. Inactive charts can only be
             * shown and accessed by activating programmatically, via setting
             * `activeChartItem`. Useful in overly elaborate contexts, where identifying
             * and editing the active chart becomes challenging.
             */
            public function get operatingMode():int {
                return _operatingMode;
            }
            
            /**
             * Sets the operating mode of this component.
             * @see get operatingMode
             */
            public function set operatingMode(value:int):void {
                if (value != _operatingMode) {
                    _operatingMode = value;
                    _operatingModeChanged = true;
                    invalidateProperties();
                }
            }
            
            // ------------------------------
            // The `activeChartItem` property
            // ------------------------------
            
            // Bindable storage for the chart being currently on top of the
            // others, receiving editing actions and dispatching events.
            [Bindable]
            private var _activeChart:LineChartLayer;
            
            /**
             * Causes a specified chart item to become active, i.e., drawn on
             * top of the others, and completely opaque.
             *
             * @param   item
             *          The data provider associated to the chart to be
             *          made active.
             */
            public function set activeChartItem(item:Object):void {
            
                // Delay until chart layers stabilize.
                callLater(function():void {
            
                        if (!item || !_dataProvider || !chartsLayer || !chartsLayer.numElements) {
                            return;
                        }
            
                        var chart:LineChartLayer = null;
                        for (var i:int = 0; i < chartsLayer.numElements; i++) {
                            const tmpChart:LineChartLayer = chartsLayer.getElementAt(i) as LineChartLayer;
                            if (!tmpChart) {
                                continue;
                            }
                            if (tmpChart.dataProvider === item) {
                                chart = tmpChart;
                                break;
                            }
                        }
            
                        _setActiveChart(chart);
                        _setChartsAvailability(_operatingMode);
                    });
            }
            
            /**
             * Unselects all selected nodes of the active chart, if applicable.
             * Dispatches a `NodalEvent.SELECTION_CHANGE` event.
             */
            public function clearSelection():void {
                if (!_activeChart) {
                    return;
                }
                _activeChart.clearSelection();
            }
            
            /**
             * Deletes all selected nodes of the active chart, if applicable.
             * Dispatches a `Nodal.CHART_DATA_CHANGE` event.
             */
            public function deleteSelection():void {
                if (!_activeChart) {
                    return;
                }
                _activeChart.deleteSelection(false);
            }
            
            /**
             * Rewrites the values of all selected nodes of the active chart, if
             * applicable.
             */
            public function patchSelection(patch:Object, dispatch:Boolean = false):void {
                if (!_activeChart || !patch) {
                    return;
                }
                _activeChart.patchSelection(patch, dispatch);
            }
            
            /**
             * Overridden to catch later style changes.
             */
            override public function styleChanged(styleProp:String):void {
                super.styleChanged(styleProp);
                if (styleProp == null || styleProp == "styleName" || styleProp == "chartStyle") {
                   _stylesChanged = true;
                   invalidateProperties();
                }
            }
            
            /**
             * Overridden to update layers as needed.
             */
            override protected function commitProperties():void {
                super.commitProperties();
            
                // Data provider
                if (_dataProviderChanged) {
            
                    _dataProviderChanged = false;
                    _provisionChartLayers(_dataProvider, chartsLayer);
                    _populateChartLayers(_dataProvider);
                    _stylesChanged = true;
            
                    // Automatically activate the last chart added.
                    const topChart:LineChartLayer = (chartsLayer && chartsLayer.numElements > 0) ?
                        chartsLayer.getElementAt(chartsLayer.numElements - 1) as LineChartLayer : null;
                    _setActiveChart(topChart);
                    _setChartsAvailability(_operatingMode);
                    if (topChart) {
                        dispatchEvent(new NodalEvent(NodalEvent.CHART_ACTIVATION, topChart.dataProvider));
                    }
                    invalidateDisplayList();
                }

                // Styles
                if (_stylesChanged) {
                    _stylesChanged = false;
                    _styleChartLayers();
                    _styleBackgroundLayer();
                    invalidateDisplayList();
                }
            
                // Grid data provider
                if (_gridDataProviderChanged) {
                    _gridDataProviderChanged = false;
                    backgroundLayer.dataProvider = _gridDataProvider;
                    invalidateDisplayList();
                }
            
                // Operating mode
                if (_operatingModeChanged) {
                    _operatingModeChanged = false;
                    _setChartsAvailability(_operatingMode);
                    invalidateDisplayList();
                }
            }
            
            /**
             * Function to be executed against every "drawable" released by the
             * `_drawablesFactory`.
             */
            private function _initDrawable(drawable:UIComponent):void {
                drawable.doubleClickEnabled = true;
                drawable.useHandCursor = true;
                drawable.buttonMode = true;
            }
            
            /**
             * Function to be executed against every decommissioned "drawable"
             * sent back to the `_drawablesFactory` for recycling.
             */
            private function _purgeDrawable(drawable:UIComponent):void {
                drawable.graphics.clear();
                drawable.x = drawable.y = 0;
            }
            
            /**
             * Function to be executed against every "chart" released by the
             * `_chartsFactory`.
             */
            private function _initChart(chart:LineChartLayer):void {
                if (!chart || !_drawablesFactory) {
                    return;
                }
            
                chart.percentWidth = 100;
                chart.percentHeight = 100;
                if (!chart.markersFactory) {
                    chart.markersFactory = _drawablesFactory;
                }
                chart.addEventListener(NodalEvent.LAYER_CLICK, _onLayerClick);
            }
            
            /**
             * Function to be executed against every decommissioned "chart"
             * sent back to the `_chartsFactory` for recycling.
             */
            private function _purgeChart(chart:LineChartLayer):void {
                chart.dataProvider = null;
                _unwireChart(chart);
                chart.removeEventListener(NodalEvent.LAYER_CLICK, _onLayerClick);
            }
            
            /**
             * Ensures the `chartLayers` container contains the correct number of
             * charts.
             */
            private function _provisionChartLayers(dataProvider:ArrayCollection, container:Group):void {
                if (!_chartsFactory || !container) {
                    return;
                }
                const numCharts:uint = dataProvider ? dataProvider.length : 0;
            
                // Append
                while (container.numElements < numCharts) {
                    const chartToAdd:LineChartLayer = LineChartLayer(_chartsFactory.give());
                    _wireChart(chartToAdd);
                    container.addElement(chartToAdd);
                }
            
                // Trim
                while (container.numElements > numCharts) {
                    const chartToRemove:LineChartLayer = LineChartLayer(container.getElementAt(container.numElements - 1));
                    _unwireChart(chartToRemove);
                    container.removeElement(chartToRemove);
                    _chartsFactory.takeBack(chartToRemove);
                }
            
            }
            
            /**
             * Respectively distributes the chart values available in the data provider
             * to the available charts.
             */
            private function _populateChartLayers(_dataProvider:ArrayCollection):void {
                if (!_dataProvider || !_dataProvider.length || !chartsLayer) {
                    return;
                }
            
                for (var i:int = 0; i < _dataProvider.length; i++) {
                    const chart:LineChartLayer = chartsLayer.getElementAt(i) as LineChartLayer;
                    if (chart) {
                        chart.dataProvider = _dataProvider[i];
                    }
                }
            }
            
            /**
             * Returns the CSSStyleDeclaration referenced by the `chartStyle` style.
             *
             * `chartStyle` itself is only a string (a CSS class name, e.g. ".myChartStyle");
             * this method resolves it to the actual declaration that contains the style rules.
             *
             * Returns `null` on failure.
             */
            private function _getChartStyles():CSSStyleDeclaration {
                const chartStyleName:* = getStyle('chartStyle');
                if (chartStyleName === undefined) {
                    return null;
                }
            
                var chartStyleDecl:CSSStyleDeclaration = _sm.getStyleDeclaration('.' + chartStyleName);
                return chartStyleDecl;
            }
            
            /**
             * Styles the common background layer drawn underneath all charts.
             */
            private function _styleBackgroundLayer():void {
                if (!backgroundLayer) {
                    return;
                }
            
                var chartStyles:CSSStyleDeclaration = _getChartStyles();
                if (!chartStyles) {
                    return;
                }
            
                // Read styles.
                const $g:Function = Helpers.$getStyle;
                const padding:uint = $g(chartStyles, 'padding', DefaultStyles.DEFAULT_PADDING);
                const layerColor:uint = $g(chartStyles, 'layerColor', DefaultStyles.DEFAULT_LAYER_COLOR);
                const chartBg:uint = $g(chartStyles, 'chartBg', DefaultStyles.DEFAULT_CHART_BG);
                const chartBgAlpha:Number = $g(chartStyles, 'chartBgAlpha', DefaultStyles.DEFAULT_CHART_ALPHA);
                const xAxisColor:uint = $g(chartStyles, 'xAxisColor', DefaultStyles.DEFAULT_X_AXIS_COLOR);
                const xAxisAlpha:Number = $g(chartStyles, 'xAxisAlpha', DefaultStyles.DEFAULT_X_AXIS_ALPHA);
                const yAxisColor:uint = $g(chartStyles, 'yAxisColor', DefaultStyles.DEFAULT_Y_AXIS_COLOR);
                const yAxisAlpha:Number = $g(chartStyles, 'yAxisAlpha', DefaultStyles.DEFAULT_Y_AXIS_ALPHA);
            
                // Set styles
                backgroundLayer.setStyle('padding', padding);
                backgroundLayer.setStyle('layerColor', layerColor);
                backgroundLayer.setStyle('chartBg', chartBg);
                backgroundLayer.setStyle('chartBgAlpha', chartBgAlpha);
                backgroundLayer.setStyle('xAxisColor', xAxisColor);
                backgroundLayer.setStyle('xAxisAlpha', xAxisAlpha);
                backgroundLayer.setStyle('yAxisColor', yAxisColor);
                backgroundLayer.setStyle('yAxisAlpha', yAxisAlpha);
            }
            
            /**
             * Compiles a set of colors for each provisioned chart layer, based on a
             * provided base color. Sets compiled styles to each chart, respectively.
             */
            private function _styleChartLayers():void {
                if (!chartsLayer || !chartsLayer.numElements ||
                        !_dataProvider || _dataProvider.length !== chartsLayer.numElements) {
                    return;
                }
            
                var chartStyles:CSSStyleDeclaration = _getChartStyles();
                if (!chartStyles) {
                    return;
                }
            
                // Read styles.
                const $g:Function = Helpers.$getStyle;
                const $h:Function = Helpers.getHue;
                const padding:uint = $g(chartStyles, 'padding', DefaultStyles.DEFAULT_PADDING);
                const lineThickness:uint = $g(chartStyles, 'lineThickness', DefaultStyles.DEFAULT_LINE_THICKNESS);
                const baseColor:uint = $g(chartStyles, 'lineColor', DefaultStyles.DEFAULT_LINE_COLOR);
                const baseColorOver:uint = $g(chartStyles, 'lineColorOver', DefaultStyles.DEFAULT_LINE_COLOR_OVER);
                const baseColorSelected:uint = $g(chartStyles, 'lineColorSelected', DefaultStyles.DEFAULT_LINE_COLOR_SELECTED);
                const baseColorAnchor:uint = $g(chartStyles, 'lineColorAnchor', DefaultStyles.DEFAULT_LINE_COLOR_ANCHOR);
                _defaultAlpha = $g(chartStyles, 'defaultAlpha', DefaultStyles.DEFAULT_CHART_ALPHA);
            
                // Set styles on each available chart. Also initialize chart alpha.
                for (var i:int = 0; i < chartsLayer.numElements; i++) {
                    const chart:LineChartLayer = chartsLayer.getElementAt(i) as LineChartLayer;
                    if (!chart) {
                        continue;
                    }
            
                    const chartDp:Object = _dataProvider.getItemAt(i);
                    if (!chartDp) {
                        continue;
                    }
            
                    const hueFactor:Number = !isNaN(chartDp.hueFactor) ? Number(chartDp.hueFactor) : 0;
                    const $s:Function = chart.setStyle;
                    $s('padding', padding);
                    $s('lineThickness', lineThickness);
                    $s('lineColor', $h(baseColor, hueFactor));
                    $s('lineColorOver', $h(baseColorOver, hueFactor));
                    $s('lineColorSelected', $h(baseColorSelected, hueFactor));
                    $s('lineColorAnchor', $h(baseColorAnchor, hueFactor));
            
                    chart.alpha = (chart === _activeChart)? 1 : _defaultAlpha;
                }
            }
            
            /**
             * Sets charts as editable and/or visible based on their `active` status and the given
             * `operatingMode`.
             */
            private function _setChartsAvailability(operatingMode:int):void {
                if (!chartsLayer || !chartsLayer.numElements) {
                    return;
                }
            
                for (var i:int; i < chartsLayer.numElements; i++) {
                    const chart:LineChartLayer = chartsLayer.getElementAt(i) as LineChartLayer;
                    if (!chart) {
                        continue;
                    }
                    chart.editable = _operatingMode !== READONLY && (_activeChart === chart || _operatingMode === NORMAL);
                    chart.visible = (_activeChart === chart) || (operatingMode !== ISOLATED);
                    chart.filters = (_activeChart === chart && ACTIVE_CHART_SHADOW) ?
                        [ACTIVE_CHART_SHADOW] : null;
                }
            }
            
            /**
             * Activates given `chart`, hooking it up for event listeners, and also
             * subjecting it to external edit actions, such as deleting its selected nodes.
             */
            private function _setActiveChart(chart:LineChartLayer):void {
                if (!chartsLayer || !chartsLayer.numElements || chart === _activeChart) {
                    return;
                }
            
                // Reset the previously active chart, if any.
                _deactivateChart(_activeChart);
                _activeChart = null;
            
                if (chart) {
                    _activeChart = chart;
                    _wireChart(chart);
            
                    chart.alpha = 1; // Shortcut, avoiding costly `_styleChartLayers`.
                    if (chartsLayer.getElementAt(chartsLayer.numElements - 1) !== chart) {
                        chartsLayer.setElementIndex(chart, chartsLayer.numElements - 1);
                    }
                }
            }
            
            /**
             * Deactivates given `chart`, removing its event listeners hooks,
             * removing its selection, and resetting its alpha to a background value.
             * Actually sending the chart to the background is not handled here.
             */
            private function _deactivateChart(chart:LineChartLayer):void {
                if (!chart) {
                    return;
                }
                chart.clearSelection();
                _unwireChart(chart);
                chart.alpha = _defaultAlpha;
            }
            
            /**
             * Removes any event listeners from given provider.
             */
            private function _unwireProvider(provider:ArrayCollection):void {
                provider.removeEventListener(CollectionEvent.COLLECTION_CHANGE, _onDpAltered);
            }
            
            /**
             * Adds needed event listeners to given provider.
             */
            private function _wireProvider(provider:ArrayCollection):void {
                provider.addEventListener(CollectionEvent.COLLECTION_CHANGE, _onDpAltered);
            }
            
            /**
             * Removes any event listeners from given chart.
             */
            private function _unwireChart(chart:LineChartLayer):void {
                if (!chart) {
                    return;
                }
            
                chart.removeEventListener(NodalEvent.SELECTION_CHANGE, _onSelectionChanged);
                chart.removeEventListener(NodalEvent.NODES_CHANGE, _onNodesChanged);
            }
            
            /**
             * Adds needed event listeners to given chart.
             */
            private function _wireChart(chart:LineChartLayer):void {
                if (!chart) {
                    return;
                }
            
                chart.addEventListener(NodalEvent.SELECTION_CHANGE, _onSelectionChanged);
                chart.addEventListener(NodalEvent.NODES_CHANGE, _onNodesChanged);
            }
            
            /**
             * Listener. Executed when at the beginning of the component initialization sequence.
             * The component is in a very raw state when this event is dispatched, i.e.,
             * the internal children have not yet been created.
             */
            private function _onPreinitialize():void {
            
            }
            
            /**
             * Listener. Executed when the current data provider is "changed in place" without
             * being replaced, i.e., an item is added or removed.
             */
            private function _onDpAltered(event:CollectionEvent):void {
                _dataProviderChanged = true;
                invalidateProperties();
            
                // To consider: only build/destroy affected items, without rebuilding everything.
            }
            
            /**
             * Listener. Executed when the active chart layer dispatched a `selectionChange`
             * event.
             */
            private function _onSelectionChanged(event:NodalEvent):void {
            
                // Re-dispatch on current target
                dispatchEvent(new NodalEvent(NodalEvent.SELECTION_CHANGE, event.payload));
            }
            
            /**
             * Listener. Executed when the active chart layer dispatches a `nodesChange`
             * event.
             */
            private function _onNodesChanged(event:NodalEvent):void {
                if (!_dataProvider || !chartsLayer || !chartsLayer.numElements) {
                    return;
                }
                const chart:LineChartLayer = event.target as LineChartLayer;
                if (!chart) {
                    return;
                }
            
                const chartDp:Object = chart.dataProvider;
                if (!chartDp) {
                    return;
                }
            
                const chartIdx:int = _dataProvider.getItemIndex(chartDp);
                if (chartIdx === -1) {
                    return;
                }
            
                dispatchEvent(new NodalEvent(NodalEvent.CHART_DATA_CHANGE, {
                                changedIndex: chartIdx,
                                changedData: chartDp
                            }));
            }
            
            /**
             * Listener. Executed when the active chart layer dispatches a `layerClick`
             * event. If operating mode allows, causes the clicked chart to become active
             * and dispatches a NodalEvent.CHART_ACTIVATION event.
             */
            private function _onLayerClick(event:NodalEvent):void {
                if (_operatingMode !== NORMAL) {
                    return;
                }
                const chart:LineChartLayer = event.target as LineChartLayer;
                if (!chart) {
                    return;
                }
                _setActiveChart(chart);
                _setChartsAvailability(_operatingMode);
                dispatchEvent(new NodalEvent(NodalEvent.CHART_ACTIVATION, chart.dataProvider));
            }
        ]]>
    </fx:Script>

    <!-- Main container -->
    <s:VGroup width="100%" height="100%"
        horizontalAlign="center">

        <!-- The stack of layers (background and chart lines). -->
        <s:Group id="layersStack"
            width="100%" height="100%">

            <!-- Common background for all charts. -->
            <components:BackgroundChartLayer
                id="backgroundLayer"
                width="100%" height="100%"
                click="{clearSelection()}"
                />

            <!-- Container for all chart layers -->
            <s:Group id="chartsLayer"
                width="100%" height="100%"/>

        </s:Group>
    </s:VGroup>

</s:Group>
