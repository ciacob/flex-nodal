<?xml version="1.0" encoding="utf-8"?>
<s:Group xmlns:fx="http://ns.adobe.com/mxml/2009"
    xmlns:s="library://ns.adobe.com/flex/spark"
    xmlns:mx="library://ns.adobe.com/flex/mx">

    <fx:Metadata>
        [Style(name="lineColor", type="uint", format="Color", inherit="false")]
        [Style(name="lineThickness", type="Number", inherit="false")]
        
        [Style(name="padding", type="Number", inherit="false")]
        
        [Style(name="layerColor", type="uint", format="Color", inherit="false")]
        
        [Style(name="chartBg", type="uint", format="Color", inherit="false")]
        [Style(name="chartBgAlpha", type="Number", inherit="false")]
        
        [Style(name="yAxisColor", type="uint", format="Color", inherit="false")]
        [Style(name="yAxisAlpha", type="Number", inherit="false")]
        
        [Style(name="xAxisColor", type="uint", format="Color", inherit="false")]
        [Style(name="xAxisAlpha", type="Number", inherit="false")]
    </fx:Metadata>

    <fx:Script>
        <![CDATA[
            import flash.display.Graphics;
            import mx.core.UIComponent;
            import com.github.ciacob.flexnodal.utils.InstanceFactory;
            import mx.core.UIComponent;
            import mx.core.UIComponent;
            
            private static const DEFAULT_PADDING:uint = 5;
            
            private static const DEFAULT_LAYER_COLOR:uint = 0xcccccc;
            
            private static const DEFAULT_CHART_BG:uint = 0xffffff;
            
            private static const DEFAULT_CHART_BG_ALPHA:Number = 0.8;
            
            private static const DEFAULT_Y_AXIS_COLOR:uint = 0x00ccff;
            
            private static const DEFAULT_Y_AXIS_ALPHA:Number = 0.6;
            
            private static const DEFAULT_X_AXIS_COLOR:uint = 0x00ffcc;
            
            private static const DEFAULT_X_AXIS_ALPHA:Number = 0.6;
            
            private static const DEFAULT_LINE_COLOR:uint = 0x000000;
            
            private static const DEFAULT_LINE_THICKNESS:uint = 2;
            
            private var _bgLayer:UIComponent;
            
            private var _chartLayer:UIComponent;
            
            private var _markerLayer:UIComponent;
            
            private var _proofedPoints:Array;
            
            // -------------------
            // The `data` property
            // -------------------
            private var _data:Array;
            
            private var _dataChanged:Boolean = false;
            
            [Bindable]
            public function set data(value:Array):void {
                if (_data !== value) {
                    _data = value;
                    _dataChanged = true;
                    invalidateProperties();
                }
            }
            
            public function get data():Array {
                return _data;
            }
            
            // -------------------------------
            // The `drawablesFactory` property
            // -------------------------------
            private var _drawablesFactory:InstanceFactory;
            
            private var _drawablesFactoryChanged:Boolean;
            
            public function get drawablesFactory():InstanceFactory {
                return _drawablesFactory;
            }
            
            public function set drawablesFactory(value:InstanceFactory):void {
                if (_drawablesFactory !== value) {
                    _drawablesFactory = value;
                    _drawablesFactoryChanged = true;
                    invalidateProperties();
                }
            }
            
            /**
             * @see Group.createChildren()
             */
            override protected function createChildren():void {
                super.createChildren();
            
                // Create and add layers
                _bgLayer = new UIComponent();
                _chartLayer = new UIComponent();
                _markerLayer = new UIComponent();
                addElement(_bgLayer);
                addElement(_chartLayer);
                addElement(_markerLayer);
            }
            
            /**
             * @see Group.commitProperties
             */
            override protected function commitProperties():void {
                super.commitProperties();
            
                if (_dataChanged) {
                    _dataChanged = false;
                    _proofedPoints = _proofPoints(_data);
                    _provisionMarkers(_proofedPoints, _markerLayer);
                    invalidateDisplayList();
                }
            
                if (_drawablesFactoryChanged) {
                    _drawablesFactoryChanged = false;
                    invalidateDisplayList();
                }
            }
            
            /**
             * @see Group.updateDisplayList
             */
            override protected function updateDisplayList(unscaledWidth:Number, unscaledHeight:Number):void {
                super.updateDisplayList(unscaledWidth, unscaledHeight);
            
                var coords:Object = _computeChartCoords(unscaledWidth, unscaledHeight, _proofedPoints);
                _drawBackground(coords);
                _drawChart(coords);
            }
            
            /**
             * Helper, reads a style with fallback.
             *
             * @param name - Name of the style to read.
             * @param $default - Default value to assume if not style can be retrieved for given name.
             */
            private function _getStyle(name:String, $default:*):* {
                var val:* = getStyle(name);
                if (val === undefined) {
                    return $default;
                }
                return val;
            }
            
            /**
             * Ensures that the point list starts at x=0 and ends at x=1.
             * Adds synthetic points if necessary.
             * Returns an array of { nx:Number, ny:Number, synthetic:Boolean }.
             * (nx/ny are normalized to 0..1 space, not pixel coords.)
             */
            private function _proofPoints(data:Array):Array {
                var result:Array = [];
            
                if (!data || data.length == 0)
                    return result;
            
                // Synthetic start
                var hasLegitStart:Boolean = (data[0][0] === 0);
                if (!hasLegitStart) {
                    result.push({nx: 0, ny: data[0][1], synthetic: true});
                }
            
                // Original points
                for (var i:int = 0; i < data.length; i++) {
                    result.push({nx: data[i][0], ny: data[i][1], synthetic: false});
                }
            
                // Synthetic end
                var hasLegitEnd:Boolean = (data[data.length - 1][0] === 1);
                if (!hasLegitEnd) {
                    result.push({nx: 1, ny: data[data.length - 1][1], synthetic: true});
                }
            
                return result;
            }
            
            /**
             * Ensures the markers layer contains as many containers as there are defined markers,
             * recycling as much as possible. Does not (re)draw them.
             */
            private function _provisionMarkers(list:Array, container:UIComponent):void {

                // Append marker slots if there are not enough
                while (_markerLayer.numChildren < _data.length) {
                    const markerToAdd:UIComponent = drawablesFactory.give();
                    _markerLayer.addChild(markerToAdd);
                    // TODO: wire added marker
                }

                // Trim marker slots if there are too many
                while (_markerLayer.numChildren > _data.length) {
                    const markerToRemove : UIComponent = UIComponent(_markerLayer.getChildAt(_markerLayer.numChildren - 1));
                    // TODO: unwire marker being removed
                    drawablesFactory.takeBack(markerToRemove);
                }
            }
            
            /**
             * Computes pixel coordinates and chart background geometry
             * from already-proofed normalized points.
             */
            private function _computeChartCoords(totalW:Number, totalH:Number, points:Array):Object {
                if (!points || points.length == 0) {
                    return {points: [], plotX: 0, plotY: 0, plotW: 0, plotH: 0};
                }
            
                // Styles
                var padding:Number = _getStyle("padding", DEFAULT_PADDING);
                var thickness:Number = _getStyle("lineThickness", DEFAULT_LINE_THICKNESS);
            
                var markerDrawRadius:Number = thickness * 2;
                var effectiveHalfMarker:Number = thickness * 2.5;
                var effectiveMarkerSize:Number = effectiveHalfMarker * 2;
            
                var plotX:Number = padding + effectiveHalfMarker;
                var plotY:Number = padding + effectiveHalfMarker;
                var plotW:Number = totalW - (padding * 2) - effectiveMarkerSize;
                var plotH:Number = totalH - (padding * 2) - effectiveMarkerSize;
            
                var bgX:Number = padding;
                var bgY:Number = padding;
                var bgW:Number = totalW - (padding * 2);
                var bgH:Number = totalH - (padding * 2);
            
                // Map normalized to pixel coords
                var pixelPoints:Array = [];
                for (var i:int = 0; i < points.length; i++) {
                    var np:Object = points[i];
                    var px:Number = plotX + np.nx * plotW;
                    var py:Number = plotY + (1 - np.ny) * plotH; // invert Y
                    pixelPoints.push({x: px, y: py, synthetic: np.synthetic});
                }
            
                return {
                        points: pixelPoints,
                        plotX: plotX,
                        plotY: plotY,
                        plotW: plotW,
                        plotH: plotH,
                        bgX: bgX,
                        bgY: bgY,
                        bgW: bgW,
                        bgH: bgH,
                        markerDrawRadius: markerDrawRadius
                    };
            }
            
            /**
             * Draws the background layers
             */
            private function _drawBackground(coords:Object):void {
                var g:Graphics = _bgLayer.graphics;
                g.clear();
            
                var totalW:Number = width;
                var totalH:Number = height;
            
                var layerColor:uint = _getStyle("layerColor", DEFAULT_LAYER_COLOR);
                var chartBg:uint = _getStyle("chartBg", DEFAULT_CHART_BG);
                var chartBgAlpha:Number = _getStyle("chartBgAlpha", DEFAULT_CHART_BG_ALPHA);
            
                var yAxisColor:uint = _getStyle("yAxisColor", DEFAULT_Y_AXIS_COLOR);
                var yAxisAlpha:Number = _getStyle("yAxisAlpha", DEFAULT_Y_AXIS_ALPHA);
            
                var xAxisColor:uint = _getStyle("xAxisColor", DEFAULT_X_AXIS_COLOR);
                var xAxisAlpha:Number = _getStyle("xAxisAlpha", DEFAULT_X_AXIS_ALPHA);
            
                // Full layer background (padded area too)
                g.beginFill(layerColor, 1);
                g.drawRect(0, 0, totalW, totalH);
                g.endFill();
            
                // Chart background (inside padded area)
                g.beginFill(chartBg, chartBgAlpha);
                g.drawRect(coords.bgX, coords.bgY, coords.bgW, coords.bgH);
                g.endFill();
            
                // Y-axis (left half of chart area)
                g.beginFill(yAxisColor, yAxisAlpha);
                g.drawRect(coords.bgX, coords.bgY, coords.bgW / 2, coords.bgH);
                g.endFill();
            
                // X-axis (bottom half of chart area) over the Y-axis fill
                g.beginFill(xAxisColor, xAxisAlpha);
                g.drawRect(coords.bgX, coords.bgY + coords.bgH / 2, coords.bgW, coords.bgH / 2);
                g.endFill();
            }
            
            /**
             * Draws the line chart
             */
            private function _drawChart(coords:Object):void {
                var g:Graphics = _chartLayer.graphics;
                g.clear();
            
                if (!coords.points.length) {
                    return;
                }
            
                var lineColor:uint = _getStyle("lineColor", DEFAULT_LINE_COLOR);
                var thickness:Number = _getStyle("lineThickness", DEFAULT_LINE_THICKNESS);
            
                // Transparent rect over chart for mouse events
                g.beginFill(0x000000, 0.001);
                g.drawRect(coords.plotX, coords.plotY, coords.plotW, coords.plotH);
                g.endFill();
            
                g.lineStyle(thickness, lineColor, 1);
            
                for (var i:int = 0; i < coords.points.length; i++) {
                    var pt:Object = coords.points[i];
                    if (i == 0) {
                        g.moveTo(pt.x, pt.y);
                    }
                    else {
                        g.lineTo(pt.x, pt.y);
                    }
            
                    // (Re)draw and place a marker UIComponent
                    const marker : UIComponent = UIComponent (_markerLayer.getChildAt(i));
                    _drawMarker (marker, lineColor, thickness, coords.markerDrawRadius, pt.synthetic);
                    _positionMarker (marker, pt);
                }
            }
            
            /**
             * (Re)draws the graphical representation of a marker.
             */
            private function _drawMarker (marker : UIComponent,
                color : uint, lineThickness : uint, circleRadius : uint,
                isSyntheticPoint : Boolean) : void {

                // Draw around origin, so that resulting graphic is anchored in its center.
                const g:Graphics = marker.graphics;
                g.clear();
                g.lineStyle(lineThickness, color, 1);
                g.beginFill(color, isSyntheticPoint ? 0.1 : 1);
                g.drawCircle(0, 0, circleRadius);
                g.endFill();
            }

            /**
             * (Re)positions an existing marker
             */
            private function _positionMarker (marker : UIComponent, point : Object) : void {
                marker.x = point.x;
                marker.y = point.y;
            }

        ]]>
    </fx:Script>
</s:Group>
