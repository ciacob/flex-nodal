<?xml version="1.0" encoding="utf-8"?>
<s:Group xmlns:fx="http://ns.adobe.com/mxml/2009"
    xmlns:s="library://ns.adobe.com/flex/spark"
    xmlns:mx="library://ns.adobe.com/flex/mx"
    resize="{_dragBoundsChanged = true}">

    <fx:Metadata>
        [Style(name="lineColor", type="uint", format="Color", inherit="false")]
        [Style(name="lineColorOver", type="uint", format="Color", inherit="false")]
        [Style(name="lineColorSelected", type="uint", format="Color", inherit="false")]
        [Style(name="lineColorAnchor", type="uint", format="Color", inherit="false")]
        
        [Style(name="lineThickness", type="Number", inherit="false")]
        
        [Style(name="padding", type="Number", inherit="false")]
        
        [Style(name="layerColor", type="uint", format="Color", inherit="false")]
        
        [Style(name="chartBg", type="uint", format="Color", inherit="false")]
        [Style(name="chartBgAlpha", type="Number", inherit="false")]
        
        [Style(name="yAxisColor", type="uint", format="Color", inherit="false")]
        [Style(name="yAxisAlpha", type="Number", inherit="false")]
        
        [Style(name="xAxisColor", type="uint", format="Color", inherit="false")]
        [Style(name="xAxisAlpha", type="Number", inherit="false")]
        
        [Event(name="selectionChange", type="com.github.ciacob.flexnodal.events.NodalEvent")]
        [Event(name="nodesChange", type="com.github.ciacob.flexnodal.events.NodalEvent")]
        [Event(name="layerChange", type="com.github.ciacob.flexnodal.events.NodalEvent")]
    </fx:Metadata>

    <fx:Script>
        <![CDATA[
            import flash.display.Graphics;
            import mx.core.UIComponent;
            import com.github.ciacob.flexnodal.utils.InstanceFactory;
            import com.github.ciacob.flexnodal.utils.Node;
            import flash.events.MouseEvent;
            import com.github.ciacob.flexnodal.utils.SelectionManager;
            import com.github.ciacob.flexnodal.events.NodalEvent;
            import com.github.ciacob.flexnodal.utils.Helpers;
            import com.github.ciacob.flexnodal.utils.Node;
            import com.github.ciacob.flexnodal.utils.ChartCoordinates;
            import com.github.ciacob.flexnodal.utils.DragDeltas;
            import flash.events.MouseEvent;
            import flash.geom.Rectangle;
            import flash.geom.Point;
            
            private static const DEFAULT_PADDING:uint = 5;
            
            private static const DEFAULT_LAYER_COLOR:uint = 0xcccccc;
            
            private static const DEFAULT_CHART_BG:uint = 0xffffff;
            
            private static const DEFAULT_CHART_BG_ALPHA:Number = 0.8;
            
            private static const DEFAULT_Y_AXIS_COLOR:uint = 0x00ccff;
            
            private static const DEFAULT_Y_AXIS_ALPHA:Number = 0.6;
            
            private static const DEFAULT_X_AXIS_COLOR:uint = 0x00ffcc;
            
            private static const DEFAULT_X_AXIS_ALPHA:Number = 0.6;
            
            private static const DEFAULT_LINE_COLOR:uint = 0x000000;
            
            private static const DEFAULT_LINE_COLOR_OVER:uint = 0x003399;
            
            private static const DEFAULT_LINE_COLOR_SELECTED:uint = 0x006699;
            
            private static const DEFAULT_LINE_COLOR_ANCHOR:uint = 0x00ffff;
            
            private static const DEFAULT_LINE_THICKNESS:uint = 2;
            
            // The container to draw background decorations in
            private var _bgLayer:UIComponent;
            
            // The container to draw the line of this chart in
            private var _chartLayer:UIComponent;
            
            // The container to draw the MARKERS of this chart in. A
            // marker is a visual representation of a chart line joint
            // that can be interacted with (e.g., via mouse).
            private var _markerLayer:UIComponent;
            
            // Cache for last computed drawing coordinates, as returned by
            // `_computeChartCoords()`.
            private var _lastKnownCoords:ChartCoordinates;
            
            // Flag to raise when the dragging boundaries have (likely)
            // changed and they need to be recomputed.
            private var _dragBoundsChanged:Boolean;
            
            // Cache for last computed drag boundaries, as returned by
            // `_computeDragBounds()`.
            private var _lastKnownDragBounds:DragDeltas;
            
            // List of all NODES that define this line chart.
            // A node is a logical representation of a marker. It
            // contains information about the state of that marker (e.g.,
            // whether it is currently selected, its originating values,
            // etc.).
            private var _nodes:Vector.<Node>;
            
            // The SelectionManager that manages selection for this line chart.
            private var _selectionManager:SelectionManager;
            
            // Flag we raise during marker dragging.
            private var _nowDragging:Boolean;
            
            // Storage for the offset between the grabbing spot and the anchor
            // point of the marker being dragged, in stage coordinates.
            private var _dragClickOffset:Point;
            
            // Storage for the screen X,Y of the marker dragging was started
            // from. Together with `_dragClickOffset` helps establishing a
            // dragging delta.
            private var _dragOrigin:Point;
            
            // Deep clone of the last known screen points, to use when computing
            // new points based on the dragging delta.
            private var _oldScreenPoints:Vector.<Point>;
            
            // -------------------
            // The `values` property
            // -------------------
            
            // Holder of all raw VALUES that define this line chart.
            // Values are user-provided doublets of abstract and
            // normalized [x,y] values, e.g.:
            // [ [0,0], [0.5,1], [1,0] ]
            // 
            // The above abstractly defines a simple chart line
            // that starts and ends at the very bottom on the Y axis,
            // while climbing fully in its middle (on the X axis),
            // thus creating a simple "hill" profile.
            private var _values:Array;
            
            // Flag to raise when the client code has externally changed
            // the input values.
            private var _valuesChanged:Boolean = false;
            
            /**
             * Sets a new set of values. Cause the chart to be
             * updated.
             */
            [Bindable]
            public function set values(value:Array):void {
                if (_values !== value) {
                    _values = value;
                    _valuesChanged = true;
                    invalidateProperties();
                }
            }
            
            /**
             * Gets the current set of values, which will reflect
             * any changes the user made to the chart (e.g., via mouse).
             */
            public function get values():Array {
                return _values;
            }
            
            // -------------------------------
            // The `markersFactory` property
            // -------------------------------
            
            // Externally injected class instance responsible for providing
            // UIComponents to represent the chart markers.
            private var _markersFactory:InstanceFactory;
            
            // Flag to raise when the client code has externally changed the
            // markers factory.
            private var _markersFactoryChanged:Boolean;
            
            /**
             * Gets the markers factory currently in use.
             */
            public function get markersFactory():InstanceFactory {
                return _markersFactory;
            }
            
            /**
             * Sets a new markers factory to use. Has no immediate effect on
             * the chart rendering.
             */
            public function set markersFactory(value:InstanceFactory):void {
                if (_markersFactory !== value) {
                    _markersFactory = value;
                    _markersFactoryChanged = true;
                    invalidateProperties();
                }
            }
            
            /**
             * Marks all nodes of the chart as unselected, also dispatching a
             * `SELECTION_CHANGE` NodalEvent (opt-out).
             *
             * @param   dispatch
             *          Optional, default `true`: whether to dispatch
             *          an event for this operation.
             */
            public function clearSelection(dispatch:Boolean = true):void {
                if (!_selectionManager) {
                    return;
                }
                if (_selectionManager.clearSelection()) {
                    if (dispatch) {
                        _broadcastSelection();
                        _dragBoundsChanged = true;
                    }
                    invalidateDisplayList();
                }
            }
            
            /**
             * Removes all selected nodes eligible for deletion, also dispatching a
             * `NODES_CHANGE` NodalEvent (opt-out).
             */
            public function deleteSelection(dispatch:Boolean = true):void {
            
                if (!_selectionManager || !_nodes || !_nodes.length || !_markerLayer) {
                    return;
                }
            
                const selectedNodes:Vector.<Node> = _selectionManager.selectedNodes.concat();
                if (!selectedNodes || !selectedNodes.length) {
                    return;
                }
            
                const numNodesBefore:uint = _nodes.length;
                _selectionManager.clearSelection();
                _broadcastSelection();
                _dragBoundsChanged = true;
                for each (var removable:Node in selectedNodes) {
            
                    // Synthetic nodes cannot be deleted.
                    if (removable.isSynthetic) {
                        continue;
                    }
            
                    // Remove the node marked for deletion.
                    const idx:int = _nodes.indexOf(removable);
                    if (idx === -1) {
                        continue;
                    }
                    _nodes.splice(idx, 1);
                }
            
                // If deletion was effective, restore integrity of the remaining dataset,
                // trim the available markers, schedule a redraw, and broadcast the changes.
                if (_nodes.length != numNodesBefore) {
                    _nodes = _proofNodes(_nodes);
                    _provisionMarkers(_nodes, _markerLayer);
                    invalidateDisplayList();
                    _values = _exportNodes(_nodes);
                    if (dispatch) {
                        dispatchEvent(new NodalEvent(NodalEvent.NODES_CHANGE));
                    }
                }
            }
            
            /**
             * Overridden to Create and add layers.
             * @see Group.createChildren()
             */
            override protected function createChildren():void {
                super.createChildren();
            
                _bgLayer = new UIComponent();
                addElement(_bgLayer);
            
                _chartLayer = new UIComponent();
                _chartLayer.buttonMode = true;
                _chartLayer.useHandCursor = true;
                _chartLayer.doubleClickEnabled = true;
                _chartLayer.addEventListener(MouseEvent.DOUBLE_CLICK, _onChartDoubleClicked);
                addElement(_chartLayer);
            
                _markerLayer = new UIComponent();
                addElement(_markerLayer);
            }
            
            /**
             * Overridden to parse incoming values and schedule (re)drawing
             * the chart.
             * @see Group.commitProperties
             */
            override protected function commitProperties():void {
                super.commitProperties();
            
                if (_valuesChanged) {
                    _valuesChanged = false;
                    _nodes = _importValues(_values);
            
                    if (!_selectionManager) {
                        _selectionManager = new SelectionManager(_nodes);
                    }
                    else {
                        _selectionManager.nodes = _nodes;
                    }
            
                    _provisionMarkers(_nodes, _markerLayer);
                    invalidateDisplayList();
                }
            
                if (_markersFactoryChanged) {
                    _markersFactoryChanged = false;
                    invalidateDisplayList();
                }
            }
            
            /**
             * Overridden to resolve nodes to current screen x,y coordinates,
             * and draw the resulting chart lines and markers.
             * @see Group.updateDisplayList
             */
            override protected function updateDisplayList(unscaledWidth:Number, unscaledHeight:Number):void {
                super.updateDisplayList(unscaledWidth, unscaledHeight);
            
                // Draw the chart if applicable
                if (!_nodes || !_nodes.length) {
                    return;
                }
                _lastKnownCoords = _computeChartCoords(unscaledWidth, unscaledHeight, _nodes);
                _drawBackground(_lastKnownCoords);
                _drawChart(_nodes, _lastKnownCoords);
            
                // Update dragging boundaries if needed.
                if (_dragBoundsChanged) {
                    _dragBoundsChanged = false;
                    _lastKnownDragBounds = _computeDragBounds();
                }
            }
            
            /**
             * Helper, returns the corresponding node for a given marker, provided both exist
             * and are correctly related. Returns `null` on failure.
             */
            private function $node(marker:UIComponent):Node {
                if (!_nodes || !_nodes.length) {
                    return null;
                }
                if (!marker || !_markerLayer || !_markerLayer.contains(marker)) {
                    return null;
                }
            
                const markerIndex:int = _markerLayer.getChildIndex(marker);
                if (markerIndex < 0 || markerIndex >= _nodes.length) {
                    return null;
                };
                return _nodes[markerIndex];
            }
            
            /**
             * Helper, returns the corresponding marker for a given node, provided both exist
             * and are correctly related. Returns `null` on failure.
             */
            private function $marker(node:Node):UIComponent {
                if (!node || !_nodes || !_nodes.length) {
                    return null;
                }
                if (!_markerLayer || !_markerLayer.numChildren) {
                    return null;
                }
                const nodeIndex:int = _nodes.indexOf(node);
                if (nodeIndex < 0 || nodeIndex >= _markerLayer.numChildren) {
                    return null;
                }
                return (_markerLayer.getChildAt(nodeIndex) as UIComponent);
            }
            
            /**
             * Helper, reads a CSS style with a fallback value.
             *
             * @param name - Name of the style to read.
             * @param fallback - Default value to assume if no style can be retrieved for given name.
             */
            private function _getStyle(name:String, fallback:*):* {
                var val:* = getStyle(name);
                if (val === undefined) {
                    return fallback;
                }
                return val;
            }
            
            /**
             * Clones current Nodes' screen coordinates in order to freeze them during dragging.
             *
             * @return  An ordered Vector of Points respectively holding the screen coordinates
             *          of all Nodes.
             */
            private function _cloneScreenPoints():Vector.<Point> {
                const clone:Vector.<Point> = new <Point>[];
                if (!_nodes || !_nodes.length) {
                    return clone;
                }
            
                for (var i:int = 0; i < _nodes.length; i++) {
                    const node:Node = _nodes[i];
                    const p:Point = new Point(node.screenX, node.screenY);
                    clone.push(p);
                }
                return clone;
            }
            
            /**
             * Adds a point based on received `x` and `y` values. Returns the created Node,
             * or `null` on failure. Also dispatches a `NODES_CHANGE` NodalEvent (opt-out).
             */
            private function _createNodeAt(x:Number, y:Number, dispatch:Boolean = true):Node {
                if (!_nodes || !_markerLayer || isNaN(x) || isNaN(y)) {
                    return null;
                }
            
                // Find the insertion point (right before the existing value)
                // having a larger `x`). Does not touch selection.
                var idx:int = 0;
                var numNodes:uint = _nodes.length;
                var leftSibling:Node = null;
                var rightSibling:Node = null;
                var currNode:Node = null;
                for (idx; idx < numNodes; idx++) {
                    currNode = _nodes[idx];
                    if (currNode.logicalX > x) {
                        rightSibling = currNode;
                        if (idx > 0) {
                            leftSibling = _nodes[idx - 1];
                        }
                        break;
                    }
                }
            
                // Try to interpolate the correct `y`, to account for imprecise
                // clicking.
                var adjustedY:Number = y;
                if (leftSibling && rightSibling) {
                    adjustedY = Helpers.interpolateYAtX(
                            leftSibling.logicalX, leftSibling.logicalY,
                            rightSibling.logicalX, rightSibling.logicalY,
                            x, y
                        );
                }
            
                // Insert a new value in the dataset and rebuild the chart
                const node:Node = new Node(x, adjustedY);
                _nodes.splice(idx, 0, node);
                _provisionMarkers(_nodes, _markerLayer);
                invalidateDisplayList();
            
                // Broadcast the changes.
                _values = _exportNodes(_nodes);
                if (dispatch) {
                    dispatchEvent(new NodalEvent(NodalEvent.NODES_CHANGE));
                }
            
                return node;
            }
            
            /**
             * Converts a single Node to an [x,y] doublet. Returns null for a missing Node.
             */
            private function _exportNode(node:Node):Array {
                if (!node) {
                    return null;
                }
                return [node.logicalX, node.logicalY];
            }
            
            /**
             * Converts several nodes to [x,y] doublets and appends them to storage.
             * Does nothing if missing `nodes` or `storage`.
             */
            private function _exportNodes(nodes:Vector.<Node>):Array {
                const out:Array = [];
                if (!nodes || !nodes.length) {
                    return out;
                }
                for each (var node:Node in nodes) {
                    // We do not export synthetic nodes.
                    if (node.isSynthetic) {
                        continue;
                    }
                    out.push(_exportNode(node));
                }
                return out;
            }
            
            /**
             * Parses incoming values into nodes.
             */
            private function _importValues(values:Array):Vector.<Node> {
                var nodes:Vector.<Node> = new <Node>[];
                if (!values || values.length == 0) {
                    return nodes;
                }
                for (var i:int = 0; i < values.length; i++) {
                    nodes.push(new Node(values[i][0], values[i][1], false));
                }
                nodes = _proofNodes(nodes);
                return nodes;
            }
            
            /**
             * Ensures that the chart always starts on `0` and ends on `1` on the
             * X axis by adding synthetic nodes if necessary.
             */
            private function _proofNodes(nodes:Vector.<Node>):Vector.<Node> {
                // Synthetic start node
                const firstNode:Node = (nodes.length > 0) ? nodes[0] : null;
                var hasLegitStart:Boolean = (firstNode && firstNode.logicalX === 0);
                if (!hasLegitStart) {
                    nodes.unshift(new Node(0, firstNode ? firstNode.logicalY : 0.5, true));
                }
            
                // Synthetic end node
                const lastNode:Node = nodes[nodes.length - 1];
                var hasLegitEnd:Boolean = (lastNode && lastNode.logicalX === 1);
                if (!hasLegitEnd) {
                    nodes.push(new Node(1, lastNode ? lastNode.logicalY : 0.5, true));
                }
            
                return nodes;
            }
            
            /**
             * Ensures the markers layer contains the correct number of markers.
             * No (re)drawing is done here.
             */
            private function _provisionMarkers(nodes:Vector.<Node>, container:UIComponent):void {
                const numNodes:uint = nodes.length;
            
                // Append
                while (_markerLayer.numChildren < numNodes) {
            
                    const markerToAdd:UIComponent = markersFactory.give();
                    _attachListeners(markerToAdd);
                    _markerLayer.addChild(markerToAdd);
                }
            
                // Trim
                while (_markerLayer.numChildren > numNodes) {
            
                    const markerToRemove:UIComponent = UIComponent(_markerLayer.getChildAt(_markerLayer.numChildren - 1));
                    _detachListeners(markerToRemove);
                    _markerLayer.removeChild(markerToRemove);
                    markersFactory.takeBack(markerToRemove);
                }
            }
            
            /**
             * Adds mouse listeners to given "marker" UIComponent.
             */
            private function _attachListeners(marker:UIComponent):void {
                marker.addEventListener(MouseEvent.CLICK, _onMarkerHandled);
                marker.addEventListener(MouseEvent.DOUBLE_CLICK, _onMarkerHandled);
                marker.addEventListener(MouseEvent.ROLL_OVER, _onMarkerHandled);
                marker.addEventListener(MouseEvent.ROLL_OUT, _onMarkerHandled);
                marker.addEventListener(MouseEvent.MOUSE_DOWN, _onMarkerHandled);
                marker.addEventListener(MouseEvent.MOUSE_UP, _onMarkerHandled);
            }
            
            /**
             * Removes mouse listeners previously added to given "marker" UIComponent.
             */
            private function _detachListeners(marker:UIComponent):void {
                marker.removeEventListener(MouseEvent.CLICK, _onMarkerHandled);
                marker.removeEventListener(MouseEvent.DOUBLE_CLICK, _onMarkerHandled);
                marker.removeEventListener(MouseEvent.ROLL_OVER, _onMarkerHandled);
                marker.removeEventListener(MouseEvent.ROLL_OUT, _onMarkerHandled);
                marker.removeEventListener(MouseEvent.MOUSE_DOWN, _onMarkerHandled);
                marker.removeEventListener(MouseEvent.MOUSE_UP, _onMarkerHandled);
            }
            
            /**
             * Listener, executes when the chart line is double clicked.
             */
            private function _onChartDoubleClicked(event:MouseEvent):void {
                if (!event || isNaN(event.localX) || isNaN(event.localY) ||
                        !_chartLayer || !_lastKnownCoords) {
                    return;
                }
            
                // Resolve screen coordinates to logic coordinates.
                const x:Number = event.localX - _lastKnownCoords.plotsAreaX;
                const y:Number = event.localY - _lastKnownCoords.plotsAreaY;
                const w:Number = _lastKnownCoords.plotsAreaW;
                const h:Number = _lastKnownCoords.plotsAreaH;
                const nx:Number = Math.max(0, Math.min(1, x / w));
                const ny:Number = Math.max(0, Math.min(1, 1 - y / h));
            
                // Create the new node.
                const node:Node = _createNodeAt(nx, ny);
            
                // Integrate the newly created node in the existing selection.
                // The SHIFT/CTRL/CMD modifiers work the same way they do when
                // selecting nodes.
                if (node && _selectionManager) {
                    _selectionManager.accountFor(event, node);
                    _broadcastSelection();
                    _dragBoundsChanged = true;
                    invalidateDisplayList();
                }
            }
            
            /**
             * Listener, executes when a "marker" UIComponent has been interacted with
             * via mouse.
             */
            private function _onMarkerHandled(event:MouseEvent):void {
                const marker:UIComponent = event.target as UIComponent;
                const node:Node = $node(marker);
                if (!event || !event.target || !node) {
                    return;
                }
            
                // Any Node touch should cause redrawing on the next cycle.
                invalidateDisplayList();
            
                switch (event.type) {
                    case MouseEvent.ROLL_OVER:
                        node.isHovered = true;
                        break;
                    case MouseEvent.ROLL_OUT:
                        node.isHovered = false;
                        break;
            
                        // Clicking a Node acts upon the existing selection.
                    case MouseEvent.CLICK:
                        if (_selectionManager.accountFor(event, node)) {
                            _broadcastSelection();
                            _dragBoundsChanged = true;
                            invalidateDisplayList();
                        }
                        break;
            
                        // Double-clicking a synthetic node converts it to a genuine node.
                    case MouseEvent.DOUBLE_CLICK:
                        if (node.isSynthetic) {
                            node.isSynthetic = false;
                            if (_selectionManager.accountFor(event, node)) {
                                _broadcastSelection();
                                _dragBoundsChanged = true;
                            }
                            invalidateDisplayList();
                        }
                        break;
            
                        // Sets up mouse monitoring for selected Nodes' markers dragging.
                    case MouseEvent.MOUSE_DOWN:
                        if (!stage ||
                                node.isSynthetic ||
                                isNaN(node.screenX) ||
                                isNaN(node.screenY) ||
                                !_lastKnownCoords) {
                            return;
                        }
            
                        // A mouse down on an unselected node with no modifiers depressed will be routed
                        // through the selection manager. This allows the user to drag an unselected node
                        // in one click, without having to select it first.
                        const noModifiers:Boolean = (!event.shiftKey && !event.ctrlKey && !event.commandKey);
                        if (!node.isSelected && noModifiers) {
                            if (_selectionManager.accountFor(event, node)) {
                                _broadcastSelection();
                                _dragBoundsChanged = true;
                                invalidateDisplayList();
                            }
                        }
            
                        // Compute `_dragClickOffset`, i.e., the X,Y values needed to convert
                        // the local mouse coordinates to stage coordinates.
                        const bounds:Rectangle = getBounds(stage);
                        if (!_dragClickOffset) {
                            _dragClickOffset = new Point;
                        }
                        _dragClickOffset.x = event.localX + bounds.x;
                        _dragClickOffset.y = event.localY + bounds.y;
            
                        // Save the point where dragging begun. We'll use it later to compute
                        // a delta, as mouse moves.
                        if (!_dragOrigin) {
                            _dragOrigin = new Point;
                        }
                        _dragOrigin.x = node.screenX;
                        _dragOrigin.y = node.screenY;
            
                        // Make an immutable snapshot of the current marker's screen points.
                        // We'll need that later to compute the new coordinates, while
                        // dragging.
                        _oldScreenPoints = _cloneScreenPoints();
            
                        // Transfer event listening to the Stage, to minimize the number
                        // of times it fires.
                        stage.addEventListener(MouseEvent.MOUSE_MOVE, _onStageMouseMove, true);
                        stage.addEventListener(MouseEvent.MOUSE_UP, _onStageMouseUp);
                        if (noModifiers) {
                            mouseChildren = false;
                            mouseEnabled = false;
                            _nowDragging = true;
                        }
                        break;
                }
            }
            
            /**
             * Triggered continuously while mouse is being moved as part of a
             * dragging operation.
             */
            private function _onStageMouseMove(event:MouseEvent):void {
                if (!_nowDragging ||
                        !event || isNaN(event.stageX) || isNaN(event.stageY) ||
                        !_lastKnownDragBounds || !_oldScreenPoints ||
                        !_selectionManager ||
                        !_nodes || !_nodes.length) {
                    return;
                }
            
                const selNodes:Vector.<Node> = _selectionManager.selectedNodes;
                if (!selNodes) {
                    return;
                }
                const numSelNodes:uint = selNodes.length;
                if (!numSelNodes) {
                    return;
                }
            
                // Compute dragging delta and clamp it to the permitted dragging bounds.
                const chartX:Number = event.stageX - _dragClickOffset.x;
                const chartY:Number = event.stageY - _dragClickOffset.y;
                var xDelta:Number = chartX - _dragOrigin.x;
                var yDelta:Number = chartY - _dragOrigin.y;
                xDelta = Math.max(_lastKnownDragBounds.leftDelta, Math.min(_lastKnownDragBounds.rightDelta, xDelta));
                yDelta = Math.max(_lastKnownDragBounds.topDelta, Math.min(_lastKnownDragBounds.bottomDelta, yDelta));
            
                // Apply delta to all selected nodes, without computing logical values (we'll
                // save that for when dragging is done).
                for (var i:int = 0; i < numSelNodes; i++) {
                    const selNode:Node = selNodes[i];
                    const selNodeIdx:int = _nodes.indexOf(selNode);
                    if (selNodeIdx === -1) {
                        continue;
                    }
            
                    selNode.screenX = _oldScreenPoints[selNodeIdx].x + xDelta;
                    selNode.screenY = _oldScreenPoints[selNodeIdx].y + yDelta;
                }
            
                _drawChart(_nodes, _lastKnownCoords);
            }
            
            /**
             * Triggered when mouse is being released anywhere over the stage,
             * to indicate the end of a dragging operation.
             */
            private function _onStageMouseUp(event:MouseEvent):void {
                if (!_nowDragging || !_lastKnownCoords || !_nodes || !_nodes.length) {
                    return;
                }
            
                // Remove stage listening and make the chart interactive again
                stage.removeEventListener(MouseEvent.MOUSE_MOVE, _onStageMouseMove, true);
                stage.removeEventListener(MouseEvent.MOUSE_UP, _onStageMouseUp);
                _nowDragging = false;
                mouseChildren = true;
                mouseEnabled = true;
            
                // Convert the new coordinates markers were dragged to into logical points,
                // and export them.
                for (var i:int = 0; i < _nodes.length; i++) {
                    const node:Node = _nodes[i];
                    const lx:Number = (node.screenX - _lastKnownCoords.plotsAreaX) / _lastKnownCoords.plotsAreaW;
                    node.logicalX = Math.max(0, Math.min(1, lx));
                    const ly:Number = 1 - ((node.screenY - _lastKnownCoords.plotsAreaY) / _lastKnownCoords.plotsAreaH);
                    node.logicalY = Math.max(0, Math.min(1, ly));
                }
                _values = _exportNodes(_nodes);
                dispatchEvent(new NodalEvent(NodalEvent.NODES_CHANGE));
            
                // Recompute the dragging bounds based on the (likely changed) node values.
                _dragBoundsChanged = true;
            
                // Redraw the chart (sanity check)
                invalidateDisplayList();
            }
            
            /**
             * Sends out information about the current chart selection.
             */
            private function _broadcastSelection():void {
                dispatchEvent(new NodalEvent(NodalEvent.SELECTION_CHANGE, {
                                selectedNodes: _exportNodes(_selectionManager.selectedNodes),
                                selectedNode: _exportNode(_selectionManager.selectedNode),
                                anchorNode: _exportNode(_selectionManager.anchorNode)
                            }));
            }
            
            /**
             * Computes selected markers' maximum drag boundaries, as top, bottom, right and left
             * deltas from the center of the least mobile marker among the selected ones.
             * Note: first and last markers can only move vertically.
             */
            private function _computeDragBounds():DragDeltas {
                if (!_lastKnownCoords ||
                        !_nodes || !_nodes.length ||
                        !_selectionManager || !_selectionManager.selectedNodes ||
                        !_selectionManager.selectedNodes.length) {
                    return null;
                }
            
                const selNodes:Vector.<Node> = _selectionManager.selectedNodes;
                const numSelNodes:uint = selNodes.length;
                const numNodes:uint = _nodes.length;
            
                var leftDelta:Number = NaN;
                var topDelta:Number = NaN;
                var rightDelta:Number = NaN;
                var bottomDelta:Number = NaN;
                for (var i:int = 0; i < numSelNodes; i++) {
                    const selNode:Node = selNodes[i];
                    var ld:Number = 0;
                    var td:Number = 0;
                    var rd:Number = 0;
                    var bd:Number = 0;
            
                    // GENERICS
                    // No Node's marker should ever be dragged outside the plotting area boundaries.
            
                    // Left delta, negative: we favor GREATER values for less movement.
                    ld = _lastKnownCoords.plotsAreaX - selNode.screenX;
                    if (isNaN(leftDelta) || leftDelta < ld) {
                        leftDelta = ld;
                    }
            
                    // Top delta, negative: we favor GREATER values for less movement.
                    td = _lastKnownCoords.plotsAreaY - selNode.screenY;
                    if (isNaN(topDelta) || topDelta < td) {
                        topDelta = td;
                    }
            
                    // Right delta, positive: we favor SMALLER values for less movement.
                    rd = _lastKnownCoords.plotsAreaX + _lastKnownCoords.plotsAreaW - selNode.screenX;
                    if (isNaN(rightDelta) || rightDelta > rd) {
                        rightDelta = rd;
                    }
            
                    // Bottom delta, positive: we favor SMALLER values for less movement.
                    bd = _lastKnownCoords.plotsAreaY + _lastKnownCoords.plotsAreaH - selNode.screenY;
                    if (isNaN(bottomDelta) || bottomDelta > bd) {
                        bottomDelta = bd;
                    }
            
                    // SPECIFICS
            
                    // Identify the selected Node in the full dataset.
                    const nodeIndex:int = _nodes.indexOf(selNode);
                    if (nodeIndex === -1) {
                        continue;
                    }
            
                    // First and last Nodes's markers can only move vertically.
                    // If selection includes any of these, we are practically locked on the Y axis.
                    if (nodeIndex == 0 || nodeIndex == numNodes - 1) {
                        leftDelta = rightDelta = 0;
                    }
                    else {
                        // No selected Node's marker should be dragged cross an unselected sibling
                        // Node's marker (except for synthetic Nodes, which can be safely run over to
                        // practically convert them to genuine nodes).
                        const leftSibling:Node = _nodes[nodeIndex - 1];
                        if (!leftSibling.isSynthetic && !leftSibling.isSelected) {
                            ld = leftSibling.screenX - selNode.screenX;
                            if (leftDelta < ld) {
                                leftDelta = ld;
                            }
                        }
            
                        const rightSibling:Node = _nodes[nodeIndex + 1];
                        if (!rightSibling.isSynthetic && !rightSibling.isSelected) {
                            rd = rightSibling.screenX - selNode.screenX;
                            if (rightDelta > rd) {
                                rightDelta = rd;
                            }
                        }
                    }
                }
                const bounds:DragDeltas = new DragDeltas(leftDelta, topDelta, rightDelta, bottomDelta);
                return bounds;
            }
            
            /**
             * Computes pixel coordinates and chart background geometry from existing nodes.
             */
            private function _computeChartCoords(
                    availableWidth:Number,
                    availableHeight:Number,
                    nodes:Vector.<Node>):ChartCoordinates {
                if (!nodes || nodes.length == 0) {
                    return ChartCoordinates.empty();
                }
            
                // Styles
                const padding:Number = _getStyle("padding", DEFAULT_PADDING);
                const thickness:Number = _getStyle("lineThickness", DEFAULT_LINE_THICKNESS);
            
                const drawnMarkerRadius:Number = thickness * 2;
                const actualMarkerHalf:Number = thickness * 2.5;
                const actualMarkerSize:Number = actualMarkerHalf * 2;
            
                const plotsAreaX:Number = padding + actualMarkerHalf;
                const plotsAreaY:Number = padding + actualMarkerHalf;
                const plotsAreaW:Number = availableWidth - (padding * 2) - actualMarkerSize;
                const plotsAreaH:Number = availableHeight - (padding * 2) - actualMarkerSize;
            
                const bgAreaX:Number = padding;
                const bgAreaY:Number = padding;
                const bgAreaW:Number = availableWidth - (padding * 2);
                const bgAreaH:Number = availableHeight - (padding * 2);
            
                // Map normalized to pixel coords
                for (var i:int = 0; i < nodes.length; i++) {
                    const node:Node = nodes[i];
                    node.screenX = plotsAreaX + node.logicalX * plotsAreaW;
                    node.screenY = plotsAreaY + (1 - node.logicalY) * plotsAreaH; // invert Y
                }
            
                return new ChartCoordinates(
                        plotsAreaX, plotsAreaY, plotsAreaW, plotsAreaH,
                        bgAreaX, bgAreaY, bgAreaW, bgAreaH,
                        drawnMarkerRadius
                    );
            }
            
            /**
             * Draws the background layers
             */
            private function _drawBackground(coords:ChartCoordinates):void {
                const g:Graphics = _bgLayer.graphics;
                g.clear();
            
                const availableW:Number = width;
                const availableH:Number = height;
            
                const layerColor:uint = _getStyle("layerColor", DEFAULT_LAYER_COLOR);
                const chartBg:uint = _getStyle("chartBg", DEFAULT_CHART_BG);
                const chartBgAlpha:Number = _getStyle("chartBgAlpha", DEFAULT_CHART_BG_ALPHA);
            
                const yAxisColor:uint = _getStyle("yAxisColor", DEFAULT_Y_AXIS_COLOR);
                const yAxisAlpha:Number = _getStyle("yAxisAlpha", DEFAULT_Y_AXIS_ALPHA);
            
                const xAxisColor:uint = _getStyle("xAxisColor", DEFAULT_X_AXIS_COLOR);
                const xAxisAlpha:Number = _getStyle("xAxisAlpha", DEFAULT_X_AXIS_ALPHA);
            
                // Full layer background (padded area too)
                g.beginFill(layerColor, 1);
                g.drawRect(0, 0, availableW, availableH);
                g.endFill();
            
                // Chart background (inside padded area)
                g.beginFill(chartBg, chartBgAlpha);
                g.drawRect(coords.bgAreaX, coords.bgAreaY, coords.bgAreaW, coords.bgAreaH);
                g.endFill();
            
                // Y-axis (left half of chart area)
                g.beginFill(yAxisColor, yAxisAlpha);
                g.drawRect(coords.bgAreaX, coords.bgAreaY, coords.bgAreaW / 2, coords.bgAreaH);
                g.endFill();
            
                // X-axis (bottom half of chart area) over the Y-axis fill
                g.beginFill(xAxisColor, xAxisAlpha);
                g.drawRect(coords.bgAreaX, coords.bgAreaY + coords.bgAreaH / 2, coords.bgAreaW, coords.bgAreaH / 2);
                g.endFill();
            }
            
            /**
             * Draws the line chart
             */
            private function _drawChart(nodes:Vector.<Node>, coords:ChartCoordinates):void {
                if (!nodes || !nodes.length) {
                    return;
                }
            
                const g:Graphics = _chartLayer.graphics;
                g.clear();
            
                // Styles
                const lineColor:uint = _getStyle("lineColor", DEFAULT_LINE_COLOR);
                const lineColorOver:uint = _getStyle("lineColorOver", DEFAULT_LINE_COLOR_OVER);
                const lineColorSelected:uint = _getStyle("lineColorSelected", DEFAULT_LINE_COLOR_SELECTED);
                const lineColorAnchor:uint = _getStyle("lineColorAnchor", DEFAULT_LINE_COLOR_ANCHOR);
                const thickness:Number = _getStyle("lineThickness", DEFAULT_LINE_THICKNESS);
            
                // 1) Draw the invisible, mouse-catch layer.
                _drawChartLines(g, nodes, thickness * 4, 0, 0.001);
            
                // 2) Draw the actual polyline.
                _drawChartLines(g, nodes, thickness, lineColor);
            
                // 3) Draw and place markers whose nodes are dirty.
                _updateMarkers(
                        nodes,
                        thickness,
                        coords.drawnMarkerRadius,
                        lineColor, // base
                        lineColorOver, // over
                        lineColorSelected, // selected
                        lineColorAnchor // anchor
            
                    );
            }
            
            /**
             * Draws only the line path for the chart.
             */
            private function _drawChartLines(g:Graphics, nodes:Vector.<Node>,
                    thickness:Number, strokeColor:uint, alpha:Number = 1):void {
                g.lineStyle(thickness, strokeColor, alpha);
            
                for (var i:int = 0; i < nodes.length; i++) {
                    const node:Node = nodes[i];
                    if (i == 0) {
                        g.moveTo(node.screenX, node.screenY);
                    }
                    else {
                        g.lineTo(node.screenX, node.screenY);
                    }
                }
            }
            
            /**
             * Draw and position markers for the given points.
             * Only redraws markers whose associated nodes are "dirty".
             */
            private function _updateMarkers(
                nodes:Vector.<Node>,
                thickness:Number,
                markerRadius:Number,
                baseColor:uint,
                overColor:uint,
                selectedColor:uint,
                anchorColor:uint
                ):void {
                
                for (var i:int = 0; i < nodes.length; i++) {
                    const node:Node = nodes[i];
                    const marker:UIComponent = $marker(node);
            
                    // Decide fill/border colors based on node state.
                    const nodeBgColor:uint = node.isSelected ? selectedColor
                        : node.isHovered ? overColor
                        : baseColor;
                    const nodeBorderColor:uint = node.isAnchor ? anchorColor : nodeBgColor;
            
                    // (Re)draw and place marker.
                    _drawMarker(marker, nodeBgColor, thickness, markerRadius, node.isSynthetic, nodeBorderColor);
                    _positionMarker(marker, node);
                }
            }
            
            /**
             * (Re)draws the graphical representation of a marker.
             */
            private function _drawMarker(marker:UIComponent,
                    color:uint, lineThickness:uint, circleRadius:uint,
                    isSyntheticPoint:Boolean, borderColor:uint):void {
            
                // Draw around origin, so that resulting graphic is anchored in its center.
                const g:Graphics = marker.graphics;
                g.clear();
                g.lineStyle(lineThickness, borderColor, 1);
                g.beginFill(color, isSyntheticPoint ? 0.1 : 1);
                g.drawCircle(0, 0, circleRadius);
                g.endFill();
            }
            
            /**
             * (Re)positions an existing marker
             */
            private function _positionMarker(marker:UIComponent, node:Node):void {
                marker.x = node.screenX;
                marker.y = node.screenY;
            }
        ]]>
    </fx:Script>
</s:Group>
