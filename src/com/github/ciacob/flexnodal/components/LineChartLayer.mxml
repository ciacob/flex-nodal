<?xml version="1.0" encoding="utf-8"?>
<s:Group xmlns:fx="http://ns.adobe.com/mxml/2009"
    xmlns:s="library://ns.adobe.com/flex/spark"
    xmlns:mx="library://ns.adobe.com/flex/mx"
    resize="{_dragBoundsChanged = true}">

    <fx:Metadata>
        [Style(name="lineColor", type="uint", format="Color", inherit="false")]
        [Style(name="lineColorOver", type="uint", format="Color", inherit="false")]
        [Style(name="lineColorSelected", type="uint", format="Color", inherit="false")]
        [Style(name="lineColorAnchor", type="uint", format="Color", inherit="false")]
        [Style(name="lineThickness", type="Number", inherit="false")]
        
        [Style(name="padding", type="Number", inherit="false")]
        
        [Event(name="selectionChange", type="com.github.ciacob.flexnodal.events.NodalEvent")]
        [Event(name="nodesChange", type="com.github.ciacob.flexnodal.events.NodalEvent")]
        [Event(name="layerClick", type="com.github.ciacob.flexnodal.events.NodalEvent")]
    </fx:Metadata>

    <fx:Script>
        <![CDATA[
            import flash.display.Graphics;
            import mx.core.UIComponent;
            import com.github.ciacob.flexnodal.utils.InstanceFactory;
            import com.github.ciacob.flexnodal.utils.Node;
            import flash.events.MouseEvent;
            import com.github.ciacob.flexnodal.utils.SelectionManager;
            import com.github.ciacob.flexnodal.events.NodalEvent;
            import com.github.ciacob.flexnodal.utils.Helpers;
            import com.github.ciacob.flexnodal.utils.Node;
            import com.github.ciacob.flexnodal.utils.ChartCoordinates;
            import com.github.ciacob.flexnodal.utils.DragDeltas;
            import flash.events.MouseEvent;
            import flash.geom.Rectangle;
            import flash.geom.Point;
            import com.github.ciacob.flexnodal.utils.DefaultStyles;
            import flash.events.MouseEvent;
            
            // The container to draw background decorations in
            private var _bgLayer:UIComponent;
            
            // The container to draw the line of this chart in
            private var _chartLayer:UIComponent;
            
            // The container to draw the MARKERS of this chart in. A
            // marker is a visual representation of a chart line joint
            // that can be interacted with (e.g., via mouse).
            private var _markerLayer:UIComponent;
            
            // Cache for last computed drawing coordinates, as returned by
            // `_computeChartCoords()`.
            private var _lastKnownCoords:ChartCoordinates;
            
            // Flag to raise when the dragging boundaries have (likely)
            // changed and they need to be recomputed.
            private var _dragBoundsChanged:Boolean;
            
            // Cache for last computed drag boundaries, as returned by
            // `_computeDragBounds()`.
            private var _lastKnownDragBounds:DragDeltas;
            
            // List of all NODES that define this line chart.
            // A node is a logical representation of a marker. It
            // contains information about the state of that marker (e.g.,
            // whether it is currently selected, its originating values,
            // etc.).
            private var _nodes:Vector.<Node>;
            
            // The SelectionManager that manages selection for this line chart.
            private var _selectionManager:SelectionManager;
            
            // Flag we raise during marker dragging.
            private var _nowDragging:Boolean;
            
            // Storage for the offset between the grabbing spot and the anchor
            // point of the marker being dragged, in stage coordinates.
            private var _dragClickOffset:Point;
            
            // Storage for the screen X,Y coordinates of the marker dragging was
            // started from. Together with `_dragClickOffset` helps establishing a
            // dragging delta.
            private var _dragOrigin:Point;
            
            // Deep clone of the last known nodes/markers "screen points". They will
            // be used computing new points based on the dragging delta.
            private var _oldScreenPoints:Vector.<Point>;
            
            // ---------------------------
            // The `dataProvider` property
            // ---------------------------
            
            // An Object, containing at the very least a `values` Array
            // property, preferably also containing a `name` and `colorIndex`.
            
            // The `values` property is expected to hold all logical [x,y]
            // points that define this line chart.
            // 
            // More specifically, `values` should be an Array of user-provided
            // doublets of abstract and normalized [x,y] values, such as:
            // [ [0,0], [0.5,1], [1,0] ]
            // 
            // The above abstractly define a simple chart line
            // that starts and ends at the very bottom on the Y axis,
            // while climbing fully in its middle (on the X axis),
            // thus creating a simple "hill" profile.
            private var _dataProvider:Object;
            
            // Flag to raise when the client code has externally changed
            // the input data provider.
            private var _dataProviderChanged:Boolean = false;
            
            /**
             * Sets a new data provider. Causes the chart to be updated.
             */
            [Bindable]
            public function set dataProvider(value:Object):void {
                if (_dataProvider !== value) {
                    _dataProvider = value;
                    _dataProviderChanged = true;
                    invalidateProperties();
                }
            }
            
            /**
             * Gets the current data provider. Its `values` will reflect
             * any changes the user has made to the chart meanwhile.
             */
            public function get dataProvider():Object {
                return _dataProvider;
            }
            
            // -------------------------------
            // The `markersFactory` property
            // -------------------------------
            
            // Externally injected class instance responsible for providing
            // UIComponents to represent the chart markers.
            private var _markersFactory:InstanceFactory;
            
            // Flag to raise when the client code has externally changed the
            // markers factory.
            private var _markersFactoryChanged:Boolean;
            
            /**
             * Gets the markers factory currently in use.
             */
            public function get markersFactory():InstanceFactory {
                return _markersFactory;
            }
            
            /**
             * Sets a new markers factory to use. Has no immediate effect on
             * the chart rendering.
             */
            public function set markersFactory(value:InstanceFactory):void {
                if (_markersFactory !== value) {
                    _markersFactory = value;
                    _markersFactoryChanged = true;
                    invalidateProperties();
                }
            }
            
            // ------------------------
            // The `chartName` property
            // ------------------------
            
            // An immutable name to use for identifying this chart
            private var _chartName:String;
            
            // Returns the name of this chart, either the one explicitly provided
            // via its data provider, or a generated one.
            public function get chartName():String {
                return _chartName;
            
            }
            
            // ----------------------
            // The `editable` property
            // ----------------------
            
            /**
             * Storage for the `editable` property.
             */
            private var _editable:Boolean = true;
            
            /**
             * Flag to raise when the `editable` property has been externally changed.
             */
            private var _editableChanged:Boolean;
            
            /**
             * Gets the current value of the `editable` property.
             */
            public function get editable():Boolean {
                return _editable;
            }
            
            /**
             * Sets the `editable` property. Setting this property to `false`
             * causes the chart to not display nodes/markers. Also, double-clicking
             * a chart line does not result in creating a node anymore. `LAYER_CLICK`
             * events will still be dispatched.
             *
             * Note: by default, all charts are created as editable.
             */
            [Bindable]
            public function set editable(value:Boolean):void {
                if (value !== _editable) {
                    _editable = value;
                    _editableChanged = true;
                    invalidateProperties();
                }
            }
            
            /**
             * Marks all nodes of the chart as unselected, also dispatching a
             * `SELECTION_CHANGE` NodalEvent (opt-out).
             *
             * @param   dispatch
             *          Optional, default `true`: whether to dispatch
             *          an event for this operation.
             */
            public function clearSelection(dispatch:Boolean = true):void {
                if (!_selectionManager) {
                    return;
                }
                if (_selectionManager.clearSelection()) {
                    if (dispatch) {
                        _broadcastSelection();
                        _dragBoundsChanged = true;
                    }
                    invalidateDisplayList();
                }
            }
            
            /**
             * Removes all selected nodes eligible for deletion, also dispatching a
             * `NODES_CHANGE` NodalEvent (opt-out).
             */
            public function deleteSelection(dispatch:Boolean = true):void {
            
                if (!_selectionManager || !_nodes || !_nodes.length || !_markerLayer) {
                    return;
                }
            
                const selectedNodes:Vector.<Node> = _selectionManager.selectedNodes.concat();
                if (!selectedNodes || !selectedNodes.length) {
                    return;
                }
            
                const numNodesBefore:uint = _nodes.length;
                _selectionManager.clearSelection();
                _broadcastSelection();
                _dragBoundsChanged = true;
                for each (var removable:Node in selectedNodes) {
            
                    // Synthetic nodes cannot be deleted.
                    if (removable.isSynthetic) {
                        continue;
                    }
            
                    // Remove the node marked for deletion.
                    const idx:int = _nodes.indexOf(removable);
                    if (idx === -1) {
                        continue;
                    }
                    _nodes.splice(idx, 1);
                }
            
                // If deletion was effective, restore integrity of the remaining dataset,
                // trim the available markers, schedule a redraw, and broadcast the changes.
                if (_nodes.length != numNodesBefore) {
                    _nodes = _proofNodes(_nodes);
                    _provisionMarkers(_nodes, _markerLayer);
                    invalidateDisplayList();
                    _dataProvider.values = _exportNodes(_nodes);
                    if (dispatch) {
                        dispatchEvent(new NodalEvent(NodalEvent.NODES_CHANGE));
                    }
                }
            }
            
            /**
             * Overridden to Create and add layers.
             * @see Group.createChildren()
             */
            override protected function createChildren():void {
                super.createChildren();
            
                _bgLayer = new UIComponent();
                addElement(_bgLayer);
            
                _chartLayer = new UIComponent();
                _chartLayer.buttonMode = true;
                _chartLayer.useHandCursor = true;
                _chartLayer.doubleClickEnabled = true;
                _chartLayer.addEventListener(MouseEvent.CLICK, _onChartClicked);
                _chartLayer.addEventListener(MouseEvent.DOUBLE_CLICK, _onChartDoubleClicked);
                addElement(_chartLayer);
            
                _markerLayer = new UIComponent();
                addElement(_markerLayer);
            }
            
            /**
             * Overridden to parse incoming values and schedule (re)drawing
             * the chart.
             * @see Group.commitProperties
             */
            override protected function commitProperties():void {
                super.commitProperties();
            
                if (_dataProviderChanged) {
                    _dataProviderChanged = false;
            
                    // Set nodes.
                    _nodes = _importValues(_dataProvider ? _dataProvider.values : null);
            
                    // Set chart name.
                    _chartName = this.uid;
                    if (_dataProvider && _dataProvider.name) {
                        _chartName = Helpers.trim(_dataProvider.name) || _chartName;
                    }
            
                    // Set up the selection manager.
                    if (!_selectionManager) {
                        _selectionManager = new SelectionManager(_nodes);
                    }
                    else {
                        _selectionManager.nodes = _nodes;
                    }
            
                    // Ensure there are as many markers as there are nodes.
                    _provisionMarkers(_nodes, _markerLayer);
            
                    // Schedule a redraw.
                    invalidateDisplayList();
                }
            
                if (_markersFactoryChanged) {
                    _markersFactoryChanged = false;
                    invalidateDisplayList();
                }
            
                if (_editableChanged) {
                    _editableChanged = false;
                    if (_selectionManager && !_editable) {
                        _selectionManager.clearSelection();
                        _broadcastSelection();
                        _dragBoundsChanged = true;
                    }
                    _provisionMarkers(_nodes, _markerLayer);
                    _chartLayer.buttonMode = _chartLayer.useHandCursor = _editable;
                    invalidateDisplayList();
                }
            }
            
            /**
             * Overridden to resolve nodes to current screen x,y coordinates,
             * and draw the resulting chart lines and markers.
             * @see Group.updateDisplayList
             */
            override protected function updateDisplayList(unscaledWidth:Number, unscaledHeight:Number):void {
                super.updateDisplayList(unscaledWidth, unscaledHeight);
            
                // Draw the chart if applicable
                if (!_nodes || !_nodes.length) {
                    return;
                }
                _lastKnownCoords = Helpers.computeChartCoords(this, unscaledWidth, unscaledHeight, _nodes);
                _reserveSpace(_lastKnownCoords);
                _drawChart(_nodes, _lastKnownCoords);
            
                // Update dragging boundaries if needed.
                if (_dragBoundsChanged) {
                    _dragBoundsChanged = false;
                    _lastKnownDragBounds = _computeDragBounds();
                }
            }
            
            /**
             * Helper, returns the corresponding node for a given marker, provided both exist
             * and are correctly related. Returns `null` on failure.
             */
            private function $node(marker:UIComponent):Node {
                if (!_nodes || !_nodes.length) {
                    return null;
                }
                if (!marker || !_markerLayer || !_markerLayer.contains(marker)) {
                    return null;
                }
            
                const markerIndex:int = _markerLayer.getChildIndex(marker);
                if (markerIndex < 0 || markerIndex >= _nodes.length) {
                    return null;
                };
                return _nodes[markerIndex];
            }
            
            /**
             * Helper, returns the corresponding marker for a given node, provided both exist
             * and are correctly related. Returns `null` on failure.
             */
            private function $marker(node:Node):UIComponent {
                if (!node || !_nodes || !_nodes.length) {
                    return null;
                }
                if (!_markerLayer || !_markerLayer.numChildren) {
                    return null;
                }
                const nodeIndex:int = _nodes.indexOf(node);
                if (nodeIndex < 0 || nodeIndex >= _markerLayer.numChildren) {
                    return null;
                }
                return (_markerLayer.getChildAt(nodeIndex) as UIComponent);
            }
            
            /**
             * Clones current Nodes' screen coordinates in order to freeze them during dragging.
             *
             * @return  An ordered Vector of Points respectively holding the screen coordinates
             *          of all Nodes.
             */
            private function _cloneScreenPoints():Vector.<Point> {
                const clone:Vector.<Point> = new <Point>[];
                if (!_nodes || !_nodes.length) {
                    return clone;
                }
            
                for (var i:int = 0; i < _nodes.length; i++) {
                    const node:Node = _nodes[i];
                    const p:Point = new Point(node.screenX, node.screenY);
                    clone.push(p);
                }
                return clone;
            }
            
            /**
             * Adds a point based on received `x` and `y` values. Returns the created Node,
             * or `null` on failure. Also dispatches a `NODES_CHANGE` NodalEvent (opt-out).
             */
            private function _createNodeAt(x:Number, y:Number, dispatch:Boolean = true):Node {
                if (!_nodes || !_markerLayer || isNaN(x) || isNaN(y)) {
                    return null;
                }
            
                // Find the insertion point (right before the existing value)
                // having a larger `x`). Does not touch selection.
                var idx:int = 0;
                var numNodes:uint = _nodes.length;
                var leftSibling:Node = null;
                var rightSibling:Node = null;
                var currNode:Node = null;
                for (idx; idx < numNodes; idx++) {
                    currNode = _nodes[idx];
                    if (currNode.logicalX > x) {
                        rightSibling = currNode;
                        if (idx > 0) {
                            leftSibling = _nodes[idx - 1];
                        }
                        break;
                    }
                }
            
                // Try to interpolate the correct `y`, to account for imprecise
                // clicking.
                var adjustedY:Number = y;
                if (leftSibling && rightSibling) {
                    adjustedY = Helpers.interpolateYAtX(
                            leftSibling.logicalX, leftSibling.logicalY,
                            rightSibling.logicalX, rightSibling.logicalY,
                            x, y
                        );
                }
            
                // Insert a new value in the dataset and rebuild the chart
                const node:Node = new Node(x, adjustedY);
                _nodes.splice(idx, 0, node);
                _provisionMarkers(_nodes, _markerLayer);
                invalidateDisplayList();
            
                // Broadcast the changes.
                _dataProvider.values = _exportNodes(_nodes);
                if (dispatch) {
                    dispatchEvent(new NodalEvent(NodalEvent.NODES_CHANGE));
                }
            
                return node;
            }
            
            /**
             * Converts a single Node to an [x,y] doublet. Returns null for a missing Node.
             */
            private function _exportNode(node:Node):Array {
                if (!node) {
                    return null;
                }
                return [node.logicalX, node.logicalY];
            }
            
            /**
             * Converts several nodes to [x,y] doublets and appends them to storage.
             * Does nothing if missing `nodes` or `storage`.
             */
            private function _exportNodes(nodes:Vector.<Node>):Array {
                const out:Array = [];
                if (!nodes || !nodes.length) {
                    return out;
                }
                for each (var node:Node in nodes) {
                    // We do not export synthetic nodes.
                    if (node.isSynthetic) {
                        continue;
                    }
                    out.push(_exportNode(node));
                }
                return out;
            }
            
            /**
             * Parses incoming values into nodes.
             */
            private function _importValues(values:Array):Vector.<Node> {
                var nodes:Vector.<Node> = new <Node>[];
                if (!values || values.length == 0) {
                    return nodes;
                }
                for (var i:int = 0; i < values.length; i++) {
                    nodes.push(new Node(values[i][0], values[i][1], false));
                }
                nodes = _proofNodes(nodes);
                return nodes;
            }
            
            /**
             * Ensures that the chart always starts on `0` and ends on `1` on the
             * X axis by adding synthetic nodes if necessary.
             */
            private function _proofNodes(nodes:Vector.<Node>):Vector.<Node> {
                // Synthetic start node
                const firstNode:Node = (nodes.length > 0) ? nodes[0] : null;
                var hasLegitStart:Boolean = (firstNode && firstNode.logicalX === 0);
                if (!hasLegitStart) {
                    nodes.unshift(new Node(0, firstNode ? firstNode.logicalY : 0.5, true));
                }
            
                // Synthetic end node
                const lastNode:Node = nodes[nodes.length - 1];
                var hasLegitEnd:Boolean = (lastNode && lastNode.logicalX === 1);
                if (!hasLegitEnd) {
                    nodes.push(new Node(1, lastNode ? lastNode.logicalY : 0.5, true));
                }
            
                return nodes;
            }
            
            /**
             * Ensures the markers layer contains the correct number of markers.
             * No (re)drawing is done here.
             */
            private function _provisionMarkers(nodes:Vector.<Node>, container:UIComponent):void {
                if (!_markersFactory) {
                    return;
                }
                const numNodes:uint = _editable ? nodes.length : 0;
            
                // Append
                while (container.numChildren < numNodes) {
            
                    const markerToAdd:UIComponent = _markersFactory.give();
                    _attachListeners(markerToAdd);
                    container.addChild(markerToAdd);
                }
            
                // Trim
                while (container.numChildren > numNodes) {
            
                    const markerToRemove:UIComponent = UIComponent(container.getChildAt(container.numChildren - 1));
                    _detachListeners(markerToRemove);
                    container.removeChild(markerToRemove);
                    _markersFactory.takeBack(markerToRemove);
                }
            }
            
            /**
             * Adds mouse listeners to given "marker" UIComponent.
             */
            private function _attachListeners(marker:UIComponent):void {
                marker.addEventListener(MouseEvent.CLICK, _onMarkerHandled);
                marker.addEventListener(MouseEvent.DOUBLE_CLICK, _onMarkerHandled);
                marker.addEventListener(MouseEvent.ROLL_OVER, _onMarkerHandled);
                marker.addEventListener(MouseEvent.ROLL_OUT, _onMarkerHandled);
                marker.addEventListener(MouseEvent.MOUSE_DOWN, _onMarkerHandled);
                marker.addEventListener(MouseEvent.MOUSE_UP, _onMarkerHandled);
            }
            
            /**
             * Removes mouse listeners previously added to given "marker" UIComponent.
             */
            private function _detachListeners(marker:UIComponent):void {
                marker.removeEventListener(MouseEvent.CLICK, _onMarkerHandled);
                marker.removeEventListener(MouseEvent.DOUBLE_CLICK, _onMarkerHandled);
                marker.removeEventListener(MouseEvent.ROLL_OVER, _onMarkerHandled);
                marker.removeEventListener(MouseEvent.ROLL_OUT, _onMarkerHandled);
                marker.removeEventListener(MouseEvent.MOUSE_DOWN, _onMarkerHandled);
                marker.removeEventListener(MouseEvent.MOUSE_UP, _onMarkerHandled);
            }
            
            /**
             * Listener, executes when the chart line is clicked. Just broadcasts
             * a NodalEvent.LAYER_CLICK event.
             */
            private function _onChartClicked(event:MouseEvent):void {
                dispatchEvent(new NodalEvent(NodalEvent.LAYER_CLICK, chartName));
            }
            
            /**
             * Listener, executes when the chart line is double clicked.
             * Creates a new Node at the closest legit location to where
             * the user double-clicked.
             */
            private function _onChartDoubleClicked(event:MouseEvent):void {
                if (!_editable ||
                        !event || isNaN(event.localX) || isNaN(event.localY) ||
                        !_chartLayer ||
                        !_lastKnownCoords) {
                    return;
                }
            
                // Resolve screen coordinates to logic coordinates.
                const x:Number = event.localX - _lastKnownCoords.plotsAreaX;
                const y:Number = event.localY - _lastKnownCoords.plotsAreaY;
                const w:Number = _lastKnownCoords.plotsAreaW;
                const h:Number = _lastKnownCoords.plotsAreaH;
                const nx:Number = Math.max(0, Math.min(1, x / w));
                const ny:Number = Math.max(0, Math.min(1, 1 - y / h));
            
                // Create the new node.
                const node:Node = _createNodeAt(nx, ny);
            
                // Integrate the newly created node in the existing selection.
                // The SHIFT/CTRL/CMD modifiers work the same way they do when
                // selecting nodes.
                if (node && _selectionManager) {
                    _selectionManager.accountFor(event, node);
                    _broadcastSelection();
                    _dragBoundsChanged = true;
                    invalidateDisplayList();
                }
            }
            
            /**
             * Listener, executes when a "marker" UIComponent has been interacted with
             * via mouse.
             */
            private function _onMarkerHandled(event:MouseEvent):void {
                if (!event || !event.target) {
                    return;
                }
            
                const marker:UIComponent = event.target as UIComponent;
                const node:Node = $node(marker);
                if (!node) {
                    return;
                }
            
                // Any Node touch should cause redrawing on the next cycle.
                invalidateDisplayList();
            
                switch (event.type) {
                    case MouseEvent.ROLL_OVER:
                        node.isHovered = true;
                        break;
                    case MouseEvent.ROLL_OUT:
                        node.isHovered = false;
                        break;
            
                        // Clicking a Node acts upon the existing selection.
                    case MouseEvent.CLICK:
                        if (_selectionManager.accountFor(event, node)) {
                            _broadcastSelection();
                            _dragBoundsChanged = true;
                            invalidateDisplayList();
                        }
                        break;
            
                        // Double-clicking a synthetic node converts it to a genuine node.
                    case MouseEvent.DOUBLE_CLICK:
                        if (node.isSynthetic) {
                            node.isSynthetic = false;
                            if (_selectionManager.accountFor(event, node)) {
                                _broadcastSelection();
                                _dragBoundsChanged = true;
                            }
                            invalidateDisplayList();
                        }
                        break;
            
                        // Mouse down on a non-synthetic node sets up dragging. Whether dragging actually occurs
                        // depends on the mouse being moved BEFORE a mouse up event is fired.
                    case MouseEvent.MOUSE_DOWN:
                        dispatchEvent(new NodalEvent(NodalEvent.LAYER_CLICK, chartName));
                        if (!stage ||
                                node.isSynthetic ||
                                isNaN(node.screenX) ||
                                isNaN(node.screenY) ||
                                !_lastKnownCoords) {
                            return;
                        }
            
                        // A mouse down on an unselected node with no modifiers depressed will be routed
                        // through the selection manager. This allows the user to drag an unselected node
                        // in one click, without having to select it first.
                        const noModifiers:Boolean = (!event.shiftKey && !event.ctrlKey && !event.commandKey);
                        if (!node.isSelected && noModifiers) {
                            if (_selectionManager.accountFor(event, node)) {
                                _broadcastSelection();
                                _dragBoundsChanged = true;
                                invalidateDisplayList();
                            }
                        }
            
                        // Compute `_dragClickOffset`, i.e., the X,Y values needed to convert
                        // the local mouse coordinates to stage coordinates.
                        const bounds:Rectangle = getBounds(stage);
                        if (!_dragClickOffset) {
                            _dragClickOffset = new Point;
                        }
                        _dragClickOffset.x = event.localX + bounds.x;
                        _dragClickOffset.y = event.localY + bounds.y;
            
                        // Save the point where dragging begun. We'll use it later to compute
                        // a delta, as mouse moves.
                        if (!_dragOrigin) {
                            _dragOrigin = new Point;
                        }
                        _dragOrigin.x = node.screenX;
                        _dragOrigin.y = node.screenY;
            
                        // Make an immutable snapshot of the current marker's screen points.
                        // We'll need that later to compute the new coordinates, while
                        // dragging.
                        _oldScreenPoints = _cloneScreenPoints();
            
                        // Transfer event listening to the Stage, to minimize the number
                        // of times it fires.
                        stage.addEventListener(MouseEvent.MOUSE_MOVE, _onStageMouseMove, true);
                        stage.addEventListener(MouseEvent.MOUSE_UP, _onStageMouseUp);
                        if (noModifiers) {
                            mouseChildren = false;
                            mouseEnabled = false;
                            _nowDragging = true;
                        }
                        break;
                }
            }
            
            /**
             * Triggered continuously while mouse is being moved as part of a
             * dragging operation. Results in selected markers being moved accordingly,
             * and the chart lines being redrawn. Actual node values are not
             * updated until mouse is released.
             */
            private function _onStageMouseMove(event:MouseEvent):void {
                if (!_nowDragging ||
                        !event || isNaN(event.stageX) || isNaN(event.stageY) ||
                        !_lastKnownDragBounds || !_oldScreenPoints ||
                        !_selectionManager ||
                        !_nodes || !_nodes.length) {
                    return;
                }
            
                const selNodes:Vector.<Node> = _selectionManager.selectedNodes;
                if (!selNodes) {
                    return;
                }
                const numSelNodes:uint = selNodes.length;
                if (!numSelNodes) {
                    return;
                }
            
                // Compute dragging delta and clamp it to the permitted dragging bounds.
                const chartX:Number = event.stageX - _dragClickOffset.x;
                const chartY:Number = event.stageY - _dragClickOffset.y;
                var xDelta:Number = chartX - _dragOrigin.x;
                var yDelta:Number = chartY - _dragOrigin.y;
                xDelta = Math.max(_lastKnownDragBounds.leftDelta, Math.min(_lastKnownDragBounds.rightDelta, xDelta));
                yDelta = Math.max(_lastKnownDragBounds.topDelta, Math.min(_lastKnownDragBounds.bottomDelta, yDelta));
            
                // Apply delta to all selected nodes, without computing logical values (we'll
                // save that for when dragging is done).
                for (var i:int = 0; i < numSelNodes; i++) {
                    const selNode:Node = selNodes[i];
                    const selNodeIdx:int = _nodes.indexOf(selNode);
                    if (selNodeIdx === -1) {
                        continue;
                    }
            
                    selNode.screenX = _oldScreenPoints[selNodeIdx].x + xDelta;
                    selNode.screenY = _oldScreenPoints[selNodeIdx].y + yDelta;
                }
            
                _drawChart(_nodes, _lastKnownCoords);
            }
            
            /**
             * Triggered when mouse is being released anywhere over the stage.
             * Finalizes a node dragging operation.
             */
            private function _onStageMouseUp(event:MouseEvent):void {
                if (!_nowDragging || !_lastKnownCoords || !_nodes || !_nodes.length) {
                    return;
                }
            
                // Remove stage listening and make the chart interactive again
                stage.removeEventListener(MouseEvent.MOUSE_MOVE, _onStageMouseMove, true);
                stage.removeEventListener(MouseEvent.MOUSE_UP, _onStageMouseUp);
                _nowDragging = false;
                mouseChildren = true;
                mouseEnabled = true;
            
                // Clear the "screen points" snapshot.
                _oldScreenPoints = null;
            
                // Convert the new coordinates markers were dragged to into logical points,
                // and export them.
                for (var i:int = 0; i < _nodes.length; i++) {
                    const node:Node = _nodes[i];
            
                    const lx:Number = (i === 0) ? 0 : (i === _nodes.length - 1) ? 1 :
                        (node.screenX - _lastKnownCoords.plotsAreaX) / _lastKnownCoords.plotsAreaW;
                    node.logicalX = Math.max(0, Math.min(1, lx));
            
                    const ly:Number = 1 - ((node.screenY - _lastKnownCoords.plotsAreaY) / _lastKnownCoords.plotsAreaH);
                    node.logicalY = Math.max(0, Math.min(1, ly));
                }
            
                _dataProvider.values = _exportNodes(_nodes);
                dispatchEvent(new NodalEvent(NodalEvent.NODES_CHANGE));
            
                // Recompute the dragging bounds based on the (likely changed) node values.
                _dragBoundsChanged = true;
            
                // Redraw the chart (sanity check)
                invalidateDisplayList();
            }
            
            /**
             * Sends out information about the current chart selection.
             */
            private function _broadcastSelection():void {
                dispatchEvent(new NodalEvent(NodalEvent.SELECTION_CHANGE, {
                                selectedNodes: _exportNodes(_selectionManager.selectedNodes),
                                selectedNode: _exportNode(_selectionManager.selectedNode),
                                anchorNode: _exportNode(_selectionManager.anchorNode)
                            }));
            }
            
            /**
             * Computes selected markers' maximum drag boundaries, as top, bottom, right and left
             * deltas from the center of the least mobile marker among the selected ones.
             * Note: first and last markers can only move vertically.
             */
            private function _computeDragBounds():DragDeltas {
                if (!_lastKnownCoords ||
                        !_nodes || !_nodes.length ||
                        !_selectionManager || !_selectionManager.selectedNodes ||
                        !_selectionManager.selectedNodes.length) {
                    return null;
                }
            
                const selNodes:Vector.<Node> = _selectionManager.selectedNodes;
                const numSelNodes:uint = selNodes.length;
                const numNodes:uint = _nodes.length;
            
                var leftDelta:Number = NaN;
                var topDelta:Number = NaN;
                var rightDelta:Number = NaN;
                var bottomDelta:Number = NaN;
                for (var i:int = 0; i < numSelNodes; i++) {
                    const selNode:Node = selNodes[i];
                    var ld:Number = 0;
                    var td:Number = 0;
                    var rd:Number = 0;
                    var bd:Number = 0;
            
                    // GENERICS
                    // No Node's marker should ever be dragged outside the plotting area boundaries.
            
                    // Left delta, negative: we favor GREATER values for less movement.
                    ld = _lastKnownCoords.plotsAreaX - selNode.screenX;
                    if (isNaN(leftDelta) || leftDelta < ld) {
                        leftDelta = ld;
                    }
            
                    // Top delta, negative: we favor GREATER values for less movement.
                    td = _lastKnownCoords.plotsAreaY - selNode.screenY;
                    if (isNaN(topDelta) || topDelta < td) {
                        topDelta = td;
                    }
            
                    // Right delta, positive: we favor SMALLER values for less movement.
                    rd = _lastKnownCoords.plotsAreaX + _lastKnownCoords.plotsAreaW - selNode.screenX;
                    if (isNaN(rightDelta) || rightDelta > rd) {
                        rightDelta = rd;
                    }
            
                    // Bottom delta, positive: we favor SMALLER values for less movement.
                    bd = _lastKnownCoords.plotsAreaY + _lastKnownCoords.plotsAreaH - selNode.screenY;
                    if (isNaN(bottomDelta) || bottomDelta > bd) {
                        bottomDelta = bd;
                    }
            
                    // SPECIFICS
            
                    // Identify the selected Node in the full dataset.
                    const nodeIndex:int = _nodes.indexOf(selNode);
                    if (nodeIndex === -1) {
                        continue;
                    }
            
                    // First and last Nodes's markers can only move vertically.
                    // If selection includes any of these, we are practically locked on the Y axis.
                    if (nodeIndex == 0 || nodeIndex == numNodes - 1) {
                        leftDelta = rightDelta = 0;
                    }
                    else {
                        // No selected Node's marker should be dragged cross an unselected sibling
                        // Node's marker (except for synthetic Nodes, which can be safely run over to
                        // practically convert them to genuine nodes).
                        const leftSibling:Node = _nodes[nodeIndex - 1];
                        if (!leftSibling.isSynthetic && !leftSibling.isSelected) {
                            ld = leftSibling.screenX - selNode.screenX;
                            if (leftDelta < ld) {
                                leftDelta = ld;
                            }
                        }
            
                        const rightSibling:Node = _nodes[nodeIndex + 1];
                        if (!rightSibling.isSynthetic && !rightSibling.isSelected) {
                            rd = rightSibling.screenX - selNode.screenX;
                            if (rightDelta > rd) {
                                rightDelta = rd;
                            }
                        }
                    }
                }
                const bounds:DragDeltas = new DragDeltas(leftDelta, topDelta, rightDelta, bottomDelta);
                return bounds;
            }
            
            /**
             * Draws the minimal graphics that will secure the space of our chart, while letting its
             * background fully click-through.
             */
            private function _reserveSpace(coords:ChartCoordinates):void {
                const g:Graphics = _bgLayer.graphics;
                g.clear();
            
                const availableW:Number = width;
                const availableH:Number = height;
                g.beginFill(0, 0.001);
                g.drawRect(0, 0, 1, availableH);
                g.drawRect(0, availableH - 1, availableW, 1);
                g.endFill();
            }
            
            /**
             * Draws the line chart
             */
            private function _drawChart(nodes:Vector.<Node>, coords:ChartCoordinates):void {
                if (!nodes || !nodes.length) {
                    return;
                }
            
                const g:Graphics = _chartLayer.graphics;
                g.clear();
            
                // Styles
                const lineColor:uint = Helpers.$getStyle(this, "lineColor", DefaultStyles.DEFAULT_LINE_COLOR);
                const lineColorOver:uint = Helpers.$getStyle(this, "lineColorOver", DefaultStyles.DEFAULT_LINE_COLOR_OVER);
                const lineColorSelected:uint = Helpers.$getStyle(this, "lineColorSelected", DefaultStyles.DEFAULT_LINE_COLOR_SELECTED);
                const lineColorAnchor:uint = Helpers.$getStyle(this, "lineColorAnchor", DefaultStyles.DEFAULT_LINE_COLOR_ANCHOR);
                const thickness:Number = Helpers.$getStyle(this, "lineThickness", DefaultStyles.DEFAULT_LINE_THICKNESS);
            
                // 1) Draw the invisible, mouse-catch layer.
                _drawChartLines(g, nodes, thickness * 4, 0, 0.001);
            
                // 2) Draw the actual polyline.
                _drawChartLines(g, nodes, thickness, lineColor);
            
                // 3) Draw and place markers whose nodes are dirty.
                if (_editable) {
            
                    _updateMarkers(
                            nodes,
                            thickness,
                            coords.drawnMarkerRadius,
                            lineColor, // base
                            lineColorOver, // over
                            lineColorSelected, // selected
                            lineColorAnchor // anchor
                        );
                }
            }
            
            /**
             * Draws only the line path for the chart.
             */
            private function _drawChartLines(g:Graphics, nodes:Vector.<Node>,
                    thickness:Number, strokeColor:uint, alpha:Number = 1):void {
                g.lineStyle(thickness, strokeColor, alpha);
            
                for (var i:int = 0; i < nodes.length; i++) {
                    const node:Node = nodes[i];
                    if (i == 0) {
                        g.moveTo(node.screenX, node.screenY);
                    }
                    else {
                        g.lineTo(node.screenX, node.screenY);
                    }
                }
            }
            
            /**
             * Draw and position markers for the given points.
             */
            private function _updateMarkers(
                    nodes:Vector.<Node>,
                    thickness:Number,
                    markerRadius:Number,
                    baseColor:uint,
                    overColor:uint,
                    selectedColor:uint,
                    anchorColor:uint
                ):void {
            
                for (var i:int = 0; i < nodes.length; i++) {
                    const node:Node = nodes[i];
                    const marker:UIComponent = $marker(node);
                    if (!marker) {
                        continue;
                    }
            
                    // Decide fill/border colors based on node state.
                    const nodeBgColor:uint = node.isSelected ? selectedColor
                        : node.isHovered ? overColor
                        : baseColor;
                    const nodeBorderColor:uint = node.isAnchor ? anchorColor : nodeBgColor;
            
                    // (Re)draw and place marker.
                    _drawMarker(marker, nodeBgColor, thickness, markerRadius, node.isSynthetic, nodeBorderColor);
                    _positionMarker(marker, node);
                }
            }
            
            /**
             * (Re)draws the graphical representation of a marker.
             */
            private function _drawMarker(marker:UIComponent,
                    color:uint, lineThickness:uint, circleRadius:uint,
                    isSyntheticPoint:Boolean, borderColor:uint):void {
            
                // Draw around origin, so that resulting graphic is anchored in its center.
                const g:Graphics = marker.graphics;
                g.clear();
                g.lineStyle(lineThickness, borderColor, 1);
                g.beginFill(color, isSyntheticPoint ? 0.1 : 1);
                g.drawCircle(0, 0, circleRadius);
                g.endFill();
            }
            
            /**
             * (Re)positions an existing marker
             */
            private function _positionMarker(marker:UIComponent, node:Node):void {
                marker.x = node.screenX;
                marker.y = node.screenY;
            }
        ]]>
    </fx:Script>
</s:Group>
