<?xml version="1.0" encoding="utf-8"?>
<s:Group xmlns:fx="http://ns.adobe.com/mxml/2009"
    xmlns:s="library://ns.adobe.com/flex/spark"
    xmlns:mx="library://ns.adobe.com/flex/mx">

    <fx:Metadata>
        [Style(name="lineColor", type="uint", format="Color", inherit="false")]
        [Style(name="lineColorOver", type="uint", format="Color", inherit="false")]
        [Style(name="lineColorSelected", type="uint", format="Color", inherit="false")]
        [Style(name="lineColorAnchor", type="uint", format="Color", inherit="false")]
        
        [Style(name="lineThickness", type="Number", inherit="false")]
        
        [Style(name="padding", type="Number", inherit="false")]
        
        [Style(name="layerColor", type="uint", format="Color", inherit="false")]
        
        [Style(name="chartBg", type="uint", format="Color", inherit="false")]
        [Style(name="chartBgAlpha", type="Number", inherit="false")]
        
        [Style(name="yAxisColor", type="uint", format="Color", inherit="false")]
        [Style(name="yAxisAlpha", type="Number", inherit="false")]
        
        [Style(name="xAxisColor", type="uint", format="Color", inherit="false")]
        [Style(name="xAxisAlpha", type="Number", inherit="false")]
        
        [Event(name="selectionChange", type="com.github.ciacob.flexnodal.events.NodalEvent")]
    </fx:Metadata>

    <fx:Script>
        <![CDATA[
            import flash.display.Graphics;
            import mx.core.UIComponent;
            import com.github.ciacob.flexnodal.utils.InstanceFactory;
            import com.github.ciacob.flexnodal.utils.Node;
            import flash.events.MouseEvent;
            import com.github.ciacob.flexnodal.utils.SelectionManager;
            import com.github.ciacob.flexnodal.events.NodalEvent;
            import com.github.ciacob.flexnodal.utils.Helpers;
            import com.github.ciacob.flexnodal.utils.Node;
            
            private static const DEFAULT_PADDING:uint = 5;
            
            private static const DEFAULT_LAYER_COLOR:uint = 0xcccccc;
            
            private static const DEFAULT_CHART_BG:uint = 0xffffff;
            
            private static const DEFAULT_CHART_BG_ALPHA:Number = 0.8;
            
            private static const DEFAULT_Y_AXIS_COLOR:uint = 0x00ccff;
            
            private static const DEFAULT_Y_AXIS_ALPHA:Number = 0.6;
            
            private static const DEFAULT_X_AXIS_COLOR:uint = 0x00ffcc;
            
            private static const DEFAULT_X_AXIS_ALPHA:Number = 0.6;
            
            private static const DEFAULT_LINE_COLOR:uint = 0x000000;
            
            private static const DEFAULT_LINE_COLOR_OVER:uint = 0x003399;
            
            private static const DEFAULT_LINE_COLOR_SELECTED:uint = 0x006699;
            
            private static const DEFAULT_LINE_COLOR_ANCHOR:uint = 0x00ffff;
            
            private static const DEFAULT_LINE_THICKNESS:uint = 2;
            
            // The container to draw background decorations in
            private var _bgLayer:UIComponent;
            
            // The container to draw the line of this chart in
            private var _chartLayer:UIComponent;
            
            // The container to draw the MARKERS of this chart in. A
            // marker is a visual representation of a chart line joint
            // that can be interacted with (e.g., via mouse).
            private var _markerLayer:UIComponent;
            
            // Cache for last computed drawing coordinates, as returned by
            // `_computeChartCoords()`.
            private var _lastKnownCoords:Object;
            
            // List of all NODES that define this line chart.
            // A node is a logical representation of a marker. It
            // contains information about the state of that marker (e.g.,
            // whether it is currently selected, its originating values,
            // etc.).
            private var _nodes:Vector.<Node>;
            
            // The SelectionManager that manages selection for this line chart.
            private var _selectionManager:SelectionManager;
            
            // -------------------
            // The `values` property
            // -------------------
            
            // Holder of all raw VALUES that define this line chart.
            // Values are user-provided doublets of abstract and
            // normalized [x,y] values, e.g.:
            // [ [0,0], [0.5,1], [1,0] ]
            // 
            // The above abstractly defines a simple chart line
            // that starts and ends at the very bottom on the Y axis,
            // while climbing fully in its middle (on the X axis),
            // thus creating a simple "hill" profile.
            private var _values:Array;
            
            // Flag to raise when the client code has externally changed
            // the input values.
            private var _valuesChanged:Boolean = false;
            
            /**
             * Sets a new set of values. Cause the chart to be
             * updated.
             */
            [Bindable]
            public function set values(value:Array):void {
                if (_values !== value) {
                    _values = value;
                    _valuesChanged = true;
                    invalidateProperties();
                }
            }
            
            /**
             * Gets the current set of values, which will reflect
             * any changes the user made to the chart (e.g., via mouse).
             */
            public function get values():Array {
                return _values;
            }
            
            // -------------------------------
            // The `markersFactory` property
            // -------------------------------
            
            // Externally injected class instance responsible for providing
            // UIComponents to represent the chart markers.
            private var _markersFactory:InstanceFactory;
            
            // Flag to raise when the client code has externally changed the
            // markers factory.
            private var _markersFactoryChanged:Boolean;
            
            /**
             * Gets the markers factory currently in use.
             */
            public function get markersFactory():InstanceFactory {
                return _markersFactory;
            }
            
            /**
             * Sets a new markers factory to use. Has no immediate effect on
             * the chart rendering.
             */
            public function set markersFactory(value:InstanceFactory):void {
                if (_markersFactory !== value) {
                    _markersFactory = value;
                    _markersFactoryChanged = true;
                    invalidateProperties();
                }
            }
            
            /**
             * Marks all nodes of the chart as unselected, also dispatching a
             * `SELECTION_CHANGE` NodalEvent (opt-out).
             *
             * @param   dispatch
             *          Optional, default `true`: whether to dispatch
             *          an event for this operation.
             */
            public function clearSelection(dispatch:Boolean = true):void {
                if (!_selectionManager) {
                    return;
                }
                if (_selectionManager.clearSelection()) {
                    if (dispatch) {
                        _broadcastSelection();
                    }
                    invalidateDisplayList();
                }
            }
            
            /**
             * Removes all selected nodes eligible for deletion, also dispatching a
             * `NODES_CHANGE` NodalEvent (opt-out).
             */
            public function deleteSelection(dispatch:Boolean = true):void {
            
                if (!_selectionManager || !_nodes || !_nodes.length || !_markerLayer) {
                    return;
                }
            
                const selectedNodes:Vector.<Node> = _selectionManager.selectedNodes.concat();
                if (!selectedNodes || !selectedNodes.length) {
                    return;
                }
            
                const numNodesBefore:uint = _nodes.length;
                _selectionManager.clearSelection();
                _broadcastSelection();
                for each (var removable:Node in selectedNodes) {
            
                    // Synthetic nodes cannot be deleted.
                    if (removable.isSynthetic) {
                        continue;
                    }
            
                    // Remove the node marked for deletion.
                    const idx:int = _nodes.indexOf(removable);
                    if (idx === -1) {
                        continue;
                    }
                    _nodes.splice(idx, 1);
                }
            
                // Mark all nodes for redrawing and repositioning.
                for (var i:int = 0; i < _nodes.length; i++) {
                    _nodes[i].isDirty = true;
                }
            
                // If deletion was effective, restore integrity of the remaining dataset,
                // trim the available markers, schedule a redraw, and broadcast the changes.
                if (_nodes.length != numNodesBefore) {
                    _nodes = _proofNodes(_nodes);
                    _provisionMarkers(_nodes, _markerLayer);
                    invalidateDisplayList();
                    _values = _exportNodes(_nodes);
                    if (dispatch) {
                        dispatchEvent(new NodalEvent(NodalEvent.NODES_CHANGE));
                    }
                }
            }
            
            /**
             * Overridden to Create and add layers.
             * @see Group.createChildren()
             */
            override protected function createChildren():void {
                super.createChildren();
            
                _bgLayer = new UIComponent();
                addElement(_bgLayer);
            
                _chartLayer = new UIComponent();
                _chartLayer.buttonMode = true;
                _chartLayer.useHandCursor = true;
                _chartLayer.doubleClickEnabled = true;
                _chartLayer.addEventListener(MouseEvent.DOUBLE_CLICK, _onChartDoubleClicked);
                addElement(_chartLayer);
            
                _markerLayer = new UIComponent();
                addElement(_markerLayer);
            }
            
            /**
             * Overridden to parse incoming values and schedule (re)drawing
             * the chart.
             * @see Group.commitProperties
             */
            override protected function commitProperties():void {
                super.commitProperties();
            
                if (_valuesChanged) {
                    _valuesChanged = false;
                    _nodes = _importValues(_values);
            
                    if (!_selectionManager) {
                        _selectionManager = new SelectionManager(_nodes);
                    }
                    else {
                        _selectionManager.nodes = _nodes;
                    }
            
                    _provisionMarkers(_nodes, _markerLayer);
                    invalidateDisplayList();
                }
            
                if (_markersFactoryChanged) {
                    _markersFactoryChanged = false;
                    invalidateDisplayList();
                }
            }
            
            /**
             * Overridden to resolve nodes to current screen x,y coordinates,
             * and draw the resulting chart lines and markers.
             * @see Group.updateDisplayList
             */
            override protected function updateDisplayList(unscaledWidth:Number, unscaledHeight:Number):void {
                super.updateDisplayList(unscaledWidth, unscaledHeight);
            
                _lastKnownCoords = _computeChartCoords(unscaledWidth, unscaledHeight, _nodes);
                _drawBackground(_lastKnownCoords);
                _drawChart(_lastKnownCoords);
            }
            
            /**
             * Helper, returns the corresponding node for a given marker, provided both exist
             * and are correctly related. Returns `null` on failure.
             */
            private function $node(marker:UIComponent):Node {
                if (!_nodes || !_nodes.length) {
                    return null;
                }
                if (!marker || !_markerLayer || !_markerLayer.contains(marker)) {
                    return null;
                }
            
                const markerIndex:int = _markerLayer.getChildIndex(marker);
                if (markerIndex < 0 || markerIndex >= _nodes.length) {
                    return null;
                };
                return _nodes[markerIndex];
            }
            
            /**
             * Helper, returns the corresponding marker for a given node, provided both exist
             * and are correctly related. Returns `null` on failure.
             */
            private function $marker(node:Node):UIComponent {
                if (!node || !_nodes || !_nodes.length) {
                    return null;
                }
                if (!_markerLayer || !_markerLayer.numChildren) {
                    return null;
                }
                const nodeIndex:int = _nodes.indexOf(node);
                if (nodeIndex < 0 || nodeIndex >= _markerLayer.numChildren) {
                    return null;
                }
                return (_markerLayer.getChildAt(nodeIndex) as UIComponent);
            }
            
            /**
             * Helper, reads a CSS style with a fallback value.
             *
             * @param name - Name of the style to read.
             * @param fallback - Default value to assume if no style can be retrieved for given name.
             */
            private function _getStyle(name:String, fallback:*):* {
                var val:* = getStyle(name);
                if (val === undefined) {
                    return fallback;
                }
                return val;
            }
            
            /**
             * Adds a point based on received `x` and `y` values. Returns the created Node,
             * or `null` on failure. Also dispatches a `NODES_CHANGE` NodalEvent (opt-out).
             */
            private function _createNodeAt(x:Number, y:Number, dispatch:Boolean = true):Node {
                if (!_nodes || !_markerLayer || isNaN(x) || isNaN(y)) {
                    return null;
                }
            
                // Find the insertion point (right before the existing value)
                // having a larger `x`). Does not touch selection.
                var idx:int = 0;
                var numNodes:uint = _nodes.length;
                var leftSibling:Node = null;
                var rightSibling:Node = null;
                var currNode:Node = null;
                for (idx; idx < numNodes; idx++) {
                    currNode = _nodes[idx];
                    if (currNode.nx > x) {
                        rightSibling = currNode;
                        if (idx > 0) {
                            leftSibling = _nodes[idx - 1];
                        }
                        break;
                    }
                }
            
                // Try to interpolate the correct `y`, to account for imprecise
                // clicking.
                var adjustedY:Number = y;
                if (leftSibling && rightSibling) {
                    adjustedY = Helpers.interpolateYAtX(
                            leftSibling.nx, leftSibling.ny,
                            rightSibling.nx, rightSibling.ny,
                            x, y
                        );
                }
            
                // Insert a new value in the dataset and rebuild the chart
                const node:Node = new Node(x, adjustedY);
                _nodes.splice(idx, 0, node);
                _provisionMarkers(_nodes, _markerLayer);
            
                // Mark all nodes for redrawing and repositioning.
                for (var i:int = 0; i < _nodes.length; i++) {
                    _nodes[i].isDirty = true;
                }
                invalidateDisplayList();
            
                // Broadcast the changes.
                _values = _exportNodes(_nodes);
                if (dispatch) {
                    dispatchEvent(new NodalEvent(NodalEvent.NODES_CHANGE));
                }
            
                return node;
            }
            
            /**
             * Converts a single Node to an [x,y] doublet. Returns null for a missing Node.
             */
            private function _exportNode(node:Node):Array {
                if (!node) {
                    return null;
                }
                return [node.nx, node.ny];
            }
            
            /**
             * Converts several nodes to [x,y] doublets and appends them to storage.
             * Does nothing if missing `nodes` or `storage`.
             */
            private function _exportNodes(nodes:Vector.<Node>):Array {
                const out:Array = [];
                if (!nodes || !nodes.length) {
                    return out;
                }
                for each (var node:Node in nodes) {
                    out.push(_exportNode(node));
                }
                return out;
            }
            
            /**
             * Parses incoming values into nodes.
             */
            private function _importValues(values:Array):Vector.<Node> {
                var nodes:Vector.<Node> = new <Node>[];
                if (!values || values.length == 0) {
                    return nodes;
                }
                for (var i:int = 0; i < values.length; i++) {
                    nodes.push(new Node(values[i][0], values[i][1], false));
                }
                nodes = _proofNodes(nodes);
                return nodes;
            }
            
            /**
             * Ensures that the chart always starts on `0` and ends on `1` on the
             * X axis by adding synthetic nodes if necessary.
             */
            private function _proofNodes(nodes:Vector.<Node>):Vector.<Node> {
                // Synthetic start node
                const firstNode:Node = (nodes.length > 0) ? nodes[0] : null;
                var hasLegitStart:Boolean = (firstNode && firstNode.nx === 0);
                if (!hasLegitStart) {
                    nodes.unshift(new Node(0, firstNode ? firstNode.ny : 0.5, true));
                }
            
                // Synthetic end node
                const lastNode:Node = nodes[nodes.length - 1];
                var hasLegitEnd:Boolean = (lastNode && lastNode.nx === 1);
                if (!hasLegitEnd) {
                    nodes.push(new Node(1, lastNode ? lastNode.ny : 0.5, true));
                }
            
                return nodes;
            }
            
            /**
             * Ensures the markers layer contains the correct number of markers.
             * No (re)drawing is done here.
             */
            private function _provisionMarkers(nodes:Vector.<Node>, container:UIComponent):void {
                const numNodes:uint = nodes.length;
            
                // Append
                while (_markerLayer.numChildren < numNodes) {
            
                    const markerToAdd:UIComponent = markersFactory.give();
                    _attachListeners(markerToAdd);
                    _markerLayer.addChild(markerToAdd);
                }
            
                // Trim
                while (_markerLayer.numChildren > numNodes) {
            
                    const markerToRemove:UIComponent = UIComponent(_markerLayer.getChildAt(_markerLayer.numChildren - 1));
                    _detachListeners(markerToRemove);
                    _markerLayer.removeChild(markerToRemove);
                    markersFactory.takeBack(markerToRemove);
                }
            }
            
            /**
             * Adds mouse listeners to given "marker" UIComponent.
             */
            private function _attachListeners(marker:UIComponent):void {
                marker.addEventListener(MouseEvent.CLICK, _onMarkerHandled);
                marker.addEventListener(MouseEvent.DOUBLE_CLICK, _onMarkerHandled);
                marker.addEventListener(MouseEvent.ROLL_OVER, _onMarkerHandled);
                marker.addEventListener(MouseEvent.ROLL_OUT, _onMarkerHandled);
                marker.addEventListener(MouseEvent.MOUSE_DOWN, _onMarkerHandled);
                marker.addEventListener(MouseEvent.MOUSE_UP, _onMarkerHandled);
            }
            
            /**
             * Removes mouse listeners previously added to given "marker" UIComponent.
             */
            private function _detachListeners(marker:UIComponent):void {
                marker.removeEventListener(MouseEvent.CLICK, _onMarkerHandled);
                marker.removeEventListener(MouseEvent.DOUBLE_CLICK, _onMarkerHandled);
                marker.removeEventListener(MouseEvent.ROLL_OVER, _onMarkerHandled);
                marker.removeEventListener(MouseEvent.ROLL_OUT, _onMarkerHandled);
                marker.removeEventListener(MouseEvent.MOUSE_DOWN, _onMarkerHandled);
                marker.removeEventListener(MouseEvent.MOUSE_UP, _onMarkerHandled);
            }
            
            /**
             * Listener, executes when the chart line is double clicked.
             */
            private function _onChartDoubleClicked(event:MouseEvent):void {
                if (!event || isNaN(event.localX) || isNaN(event.localY) ||
                        !_chartLayer || !_lastKnownCoords) {
                    return;
                }
            
                // Resolve screen coordinates to logic coordinates.
                const x:Number = event.localX - _lastKnownCoords.plotsAreaX;
                const y:Number = event.localY - _lastKnownCoords.plotsAreaY;
                const w:Number = _lastKnownCoords.plotsAreaW;
                const h:Number = _lastKnownCoords.plotsAreaH;
                const nx:Number = Math.max(0, Math.min(1, x / w));
                const ny:Number = Math.max(0, Math.min(1, 1 - y / h));
            
                // Create the new node.
                const node:Node = _createNodeAt(nx, ny);
            
                // Integrate the newly created node in the existing selection.
                // The SHIFT/CTRL/CMD modifiers work the same way they do when
                // selecting nodes.
                if (node && _selectionManager) {
                    _selectionManager.accountFor(event, node);
                    _broadcastSelection();
                    invalidateDisplayList();
                }
            }
            
            /**
             * Listener, executes when a "marker" UIComponent has been interacted with
             * via mouse.
             */
            private function _onMarkerHandled(event:MouseEvent):void {
                const marker:UIComponent = event.target as UIComponent;
                const node:Node = $node(marker);
                if (!node) {
                    return;
                }
            
                // Any touched node should be redrawn on the next cycle.
                node.isDirty = true;
                invalidateDisplayList();
            
                switch (event.type) {
                    case MouseEvent.ROLL_OVER:
                        node.isHovered = true;
                        break;
                    case MouseEvent.ROLL_OUT:
                        node.isHovered = false;
                        break;
            
                        // Clicking a Node acts upon the existing selection.
                    case MouseEvent.CLICK:
                        if (_selectionManager.accountFor(event, node)) {
                            _broadcastSelection();
                            invalidateDisplayList();
                        }
                        break;
            
                        // Double-clicking a synthetic node converts it to a genuine node.
                    case MouseEvent.DOUBLE_CLICK:
                        if (node.isSynthetic) {
                            node.isSynthetic = false;
                            node.isDirty = true;
                            if (_selectionManager.accountFor(event, node)) {
                                _broadcastSelection();        
                            }
                            invalidateDisplayList();
                        }
                        break;
                }
            }
            
            /**
             * Sends out information about the current chart selection.
             */
            private function _broadcastSelection():void {
                dispatchEvent(new NodalEvent(NodalEvent.SELECTION_CHANGE, {
                                selectedNodes: _exportNodes(_selectionManager.selectedNodes),
                                selectedNode: _exportNode(_selectionManager.selectedNode),
                                anchorNode: _exportNode(_selectionManager.anchorNode)
                            }));
            }
            
            /**
             * Computes pixel coordinates and chart background geometry
             * from existing nodes.
             */
            private function _computeChartCoords(availableWidth:Number, availableHeight:Number, nodes:Vector.<Node>):Object {
                if (!nodes || nodes.length == 0) {
                    return {screenPoints: [], plotsAreaX: 0, plotsAreaY: 0, plotsAreaW: 0, plotsAreaH: 0};
                }
            
                // Styles
                var padding:Number = _getStyle("padding", DEFAULT_PADDING);
                var thickness:Number = _getStyle("lineThickness", DEFAULT_LINE_THICKNESS);
            
                var drawnMarkerRadius:Number = thickness * 2;
                var actualMarkerHalf:Number = thickness * 2.5;
                var actualMarkerSize:Number = actualMarkerHalf * 2;
            
                var plotsAreaX:Number = padding + actualMarkerHalf;
                var plotsAreaY:Number = padding + actualMarkerHalf;
                var plotsAreaW:Number = availableWidth - (padding * 2) - actualMarkerSize;
                var plotsAreaH:Number = availableHeight - (padding * 2) - actualMarkerSize;
            
                var bgAreaX:Number = padding;
                var bgAreaY:Number = padding;
                var bgAreaW:Number = availableWidth - (padding * 2);
                var bgAreaH:Number = availableHeight - (padding * 2);
            
                // Map normalized to pixel coords
                var screenPoints:Array = [];
                for (var i:int = 0; i < nodes.length; i++) {
                    var node:Node = nodes[i];
                    var sx:Number = plotsAreaX + node.nx * plotsAreaW;
                    var sy:Number = plotsAreaY + (1 - node.ny) * plotsAreaH; // invert Y
                    screenPoints.push({x: sx, y: sy, synthetic: node.isSynthetic});
                }
            
                return {
                        screenPoints: screenPoints,
                        plotsAreaX: plotsAreaX,
                        plotsAreaY: plotsAreaY,
                        plotsAreaW: plotsAreaW,
                        plotsAreaH: plotsAreaH,
                        bgAreaX: bgAreaX,
                        bgAreaY: bgAreaY,
                        bgAreaW: bgAreaW,
                        bgAreaH: bgAreaH,
                        drawnMarkerRadius: drawnMarkerRadius
                    };
            }
            
            /**
             * Draws the background layers
             */
            private function _drawBackground(coords:Object):void {
                var g:Graphics = _bgLayer.graphics;
                g.clear();
            
                var availableW:Number = width;
                var availableH:Number = height;
            
                var layerColor:uint = _getStyle("layerColor", DEFAULT_LAYER_COLOR);
                var chartBg:uint = _getStyle("chartBg", DEFAULT_CHART_BG);
                var chartBgAlpha:Number = _getStyle("chartBgAlpha", DEFAULT_CHART_BG_ALPHA);
            
                var yAxisColor:uint = _getStyle("yAxisColor", DEFAULT_Y_AXIS_COLOR);
                var yAxisAlpha:Number = _getStyle("yAxisAlpha", DEFAULT_Y_AXIS_ALPHA);
            
                var xAxisColor:uint = _getStyle("xAxisColor", DEFAULT_X_AXIS_COLOR);
                var xAxisAlpha:Number = _getStyle("xAxisAlpha", DEFAULT_X_AXIS_ALPHA);
            
                // Full layer background (padded area too)
                g.beginFill(layerColor, 1);
                g.drawRect(0, 0, availableW, availableH);
                g.endFill();
            
                // Chart background (inside padded area)
                g.beginFill(chartBg, chartBgAlpha);
                g.drawRect(coords.bgAreaX, coords.bgAreaY, coords.bgAreaW, coords.bgAreaH);
                g.endFill();
            
                // Y-axis (left half of chart area)
                g.beginFill(yAxisColor, yAxisAlpha);
                g.drawRect(coords.bgAreaX, coords.bgAreaY, coords.bgAreaW / 2, coords.bgAreaH);
                g.endFill();
            
                // X-axis (bottom half of chart area) over the Y-axis fill
                g.beginFill(xAxisColor, xAxisAlpha);
                g.drawRect(coords.bgAreaX, coords.bgAreaY + coords.bgAreaH / 2, coords.bgAreaW, coords.bgAreaH / 2);
                g.endFill();
            }
            
            /**
             * Draws the line chart
             */
            private function _drawChart(coords:Object):void {
                const g:Graphics = _chartLayer.graphics;
                g.clear();
            
                const points:Array = coords.screenPoints;
                if (!points || !points.length) {
                    return;
                }
            
                // styles
                const lineColor:uint = _getStyle("lineColor", DEFAULT_LINE_COLOR);
                const lineColorOver:uint = _getStyle("lineColorOver", DEFAULT_LINE_COLOR_OVER);
                const lineColorSelected:uint = _getStyle("lineColorSelected", DEFAULT_LINE_COLOR_SELECTED);
                const lineColorAnchor:uint = _getStyle("lineColorAnchor", DEFAULT_LINE_COLOR_ANCHOR);
                const thickness:Number = _getStyle("lineThickness", DEFAULT_LINE_THICKNESS);
            
                // 1) Draw the invisible, mouse-catch layer.
                _drawChartLines(g, points, thickness * 4, 0, 0.001);
            
                // 2) Draw the actual polyline.
                _drawChartLines(g, points, thickness, lineColor);
            
                // 3) Draw and place markers whose nodes are dirty.
                _updateMarkers(
                        points,
                        thickness,
                        coords.drawnMarkerRadius,
                        {
                            base: lineColor,
                            over: lineColorOver,
                            selected: lineColorSelected,
                            anchor: lineColorAnchor
                        }
                    );
            }
            
            /**
             * Draws only the line path for the chart.
             */
            private function _drawChartLines(g:Graphics, points:Array, thickness:Number, strokeColor:uint, alpha:Number = 1):void {
                g.lineStyle(thickness, strokeColor, alpha);
            
                for (var i:int = 0; i < points.length; i++) {
                    const sp:Object = points[i];
                    if (i == 0) {
                        g.moveTo(sp.x, sp.y);
                    }
                    else {
                        g.lineTo(sp.x, sp.y);
                    }
                }
            }
            
            /**
             * Draw and position markers for the given points.
             * Only redraws markers whose associated nodes are "dirty".
             */
            private function _updateMarkers(points:Array, thickness:Number, markerRadius:Number, colors:Object):void {
                // Expecting colors: { base:uint, over:uint, selected:uint, anchor:uint }
                for (var i:int = 0; i < points.length; i++) {
                    const sp:Object = points[i];
            
                    // Each point uses the i-th marker
                    const marker:UIComponent = UIComponent(_markerLayer.getChildAt(i));
            
                    // Lookup the associated node for dirtiness/state
                    const node:Node = $node(marker);
                    if (!node || !node.isDirty) {
                        continue;
                    }
            
                    // Decide fill/border based on node state
                    const nodeBgColor:uint = node.isSelected ? colors.selected
                        : node.isHovered ? colors.over
                        : colors.base;
            
                    const nodeBorderColor:uint = node.isAnchor ? colors.anchor : nodeBgColor;
            
                    // (Re)draw + place marker
                    _drawMarker(marker, nodeBgColor, thickness, markerRadius, sp.synthetic, nodeBorderColor);
                    _positionMarker(marker, sp);
            
                    // Clear the dirtiness flag
                    node.isDirty = false;
                }
            }
            
            /**
             * (Re)draws the graphical representation of a marker.
             */
            private function _drawMarker(marker:UIComponent,
                    color:uint, lineThickness:uint, circleRadius:uint,
                    isSyntheticPoint:Boolean, borderColor:uint):void {
            
                // Draw around origin, so that resulting graphic is anchored in its center.
                const g:Graphics = marker.graphics;
                g.clear();
                g.lineStyle(lineThickness, borderColor, 1);
                g.beginFill(color, isSyntheticPoint ? 0.1 : 1);
                g.drawCircle(0, 0, circleRadius);
                g.endFill();
            }
            
            /**
             * (Re)positions an existing marker
             */
            private function _positionMarker(marker:UIComponent, point:Object):void {
                marker.x = point.x;
                marker.y = point.y;
            }
        ]]>
    </fx:Script>
</s:Group>
