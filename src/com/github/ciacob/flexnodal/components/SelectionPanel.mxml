<?xml version="1.0" encoding="utf-8"?>
<s:TileGroup
    xmlns:fx="http://ns.adobe.com/mxml/2009"
    xmlns:s="library://ns.adobe.com/flex/spark"
    xmlns:mx="library://ns.adobe.com/flex/mx" xmlns:spark="mx.skins.spark.*"
    requestedColumnCount="2"
    columnAlign="justifyUsingGap"
    rowAlign="justifyUsingGap"

    padding="{getStyle ('padding') || 0}"
    horizontalGap="{getStyle('horizontalGap') || 0}"
    verticalGap="{getStyle('verticalGap') || 0}"
    rowHeight="{getStyle('rowHeight') || 0}"
    minHeight="{getStyle('minHeight') || 0}"

    verticalAlign="middle">

    <fx:Metadata>
        [Event(name="selectionPatch", type="com.github.ciacob.flexnodal.events.NodalEvent")]
        
        [Style(name="headerStyle", type="String", inherit="false")]
        [Style(name="bodyStyle", type="String", inherit="false")]
        [Style(name="buttonStyle", type="String", inherit="false")]
    </fx:Metadata>

    <fx:Script>
        <![CDATA[
            import spark.components.NumericStepper;
            import com.github.ciacob.flexnodal.events.NodalEvent;
            
            // The name of the current chart; displayed at the top of the panel.
            [Bindable]
            public var chartName:String;
            
            /**
             * Overridable function that translates a time percent (e.g., `0.5`) to a label.
             * Default function just puts `time` in standard percent format (e.g. `50%`).
             */
            public var timeToLabel:Function = function(time:Number):String {
                return _toPercent(time) + '%';
            };
            
            // UI visibility flag to raise when there is any selection
            [Bindable]
            private var _haveSelection:Boolean;
            
            // UI visibility flag to raise when we are in single selection scenario.
            [Bindable]
            private var _haveSingleSelection:Boolean;
            
            // UI visibility flag to raise when we are in multiple selection scenario.
            [Bindable]
            private var _haveMultipleSelection:Boolean;
            
            // UI visibility flag to raise when we have a non-empty range (i.e., minimum
            // is not the same as maximum).
            [Bindable]
            private var _haveRange:Boolean;
            
            // UI visibility flag to raise when we have an empty range (i.e., minimum is the
            // same as maximum);
            [Bindable]
            private var _haveEmptyRange:Boolean;
            
            // UI visibility flag to raise when we have either a single selection, or a
            // no-range multiple selection (all selected nodes have the same value).
            [Bindable]
            private var _haveCommonValue:Boolean;
            
            // Storage for the current number of selected nodes.
            [Bindable]
            private var _numNodes:int;
            
            // Storage for the value of the currently selected node (single selection scenario).
            [Bindable]
            private var _currValue:int;
            
            // Storage for the `minimum` property to pass to the "Offset" Numeric Stepper component.
            [Bindable]
            private var _offsetMin:int;
            
            // Storage for the `maximum` property to pass to the "Offset" Numeric Stepper component.
            [Bindable]
            private var _offsetMax:int;
            
            // Storage for the time of the currently selected node (single selection scenario).
            [Bindable]
            private var _currNodeTime:String;
            
            // Storage for the minimum of all selected values (multiple selection scenario).
            [Bindable]
            private var _minRangeValue:Number;
            
            // Storage for the maximum of all selected values (multiple selection scenario).
            [Bindable]
            private var _maxRangeValue:Number;
            
            // Storage for the average of all selected values (multiple selection scenario).
            [Bindable]
            private var _avgRangeValue:Number;
            
            // Storage for the last known offset applied to selected nodes (multiple
            // selection scenario).
            private var _currOffset:Number = 0;
            
            // Storage for the last known selection hash. Used to determine if selection
            // has been changed outside the SelectionPanel component.
            private var _selectionHash:String;
            
            // ---------------------------
            // The `dataProvider` property
            // ---------------------------
            
            // Internal storage for the `dataProvider` property
            private var _dataProvider:Object;
            
            // Flag we raise when the `dataProvider` property has been externally changed
            private var _dataProviderChanged:Boolean;
            
            /**
             * Returns the current data provider of this component. Reflects internal
             * changes.
             */
            public function get dataProvider():Object {
                return _dataProvider;
            }
            
            /**
             * Sets or replaces a data provider for this component.
             * @param   value
             *          A user provided dataset to be used as data provider.
             *          Must pass validation in order to be accepted. Example of
             *          valid datasets:
             *
             *          Single selection:
             *          {
             *              "selectedNode":[0.5,0.8],
             *              "anchorNode":[0.5,0.8],
             *              "selectedNodes":[[0.5,0.8]]
             *          }
             *
             *          Multiple selection:
             *          {
             *              "selectedNode":[1,0],
             *              "anchorNode":[1,0],
             *              "selectedNodes":[[0.5,0.8],[0.95,0],[1,0]]
             *          }
             *
             *          If a provided dataset does not pass validation, `null` is
             *          assumed instead.
             *
             *          N.B.: The component operates destructively on the provided
             *          dataset rather than on a detached copy. This is by design.
             */
            public function set dataProvider(value:Object):void {
                if (value !== _dataProvider) {
                    _dataProvider = _validateDataProvider(value) ? value : null;
                    _dataProviderChanged = true;
                    invalidateProperties();
                }
            }
            
            /**
             * Overridden to handle setting/replacing the data provider.
             */
            override protected function commitProperties():void {
                super.commitProperties();
            
                // Data provider
                if (_dataProviderChanged) {
                    _dataProviderChanged = false;
                    _reset();
                    if (_dataProvider) {
                        _numNodes = _dataProvider.selectedNodes.length;
                        if (_numNodes) {
            
                            // Common to single and multiple selection scenarios
                            const selectedNode:Array = _dataProvider.selectedNode;
                            _currValue = _toPercent(selectedNode[1]);
                            _currNodeTime = (timeToLabel !== null) ?
                                timeToLabel(selectedNode[0]) : "";
            
                            // Multiple selection scenario
                            if (_numNodes > 1) {
                                const stats:Object = _analyzeY(_dataProvider.selectedNodes);
                                _minRangeValue = _toPercent(stats.min);
                                _maxRangeValue = _toPercent(stats.max);
                                _avgRangeValue = _toPercent(stats.avg);
            
                                const hash:String = _hashSelectionContext(chartName, _dataProvider.selectedNodes);
                                trace(':::HASH:::', hash);
                                if (hash !== _selectionHash) {
                                    _selectionHash = hash;
                                    _offsetMin = _toPercent(-stats.min);
                                    _offsetMax = _toPercent(1 - stats.max);
                                    _currOffset = 0;
                                }
                            }
                        }
                    }
                    _updateUi();
                }
            }
            
            /**
             * Creates a unique, deterministic representation of the current selection,
             * based on given `chartName` and `selectedNodes`. Relies on the fact that
             * selected nodes maintain their indices and "y" values when patched.
             */
            private function _hashSelectionContext(chartName:String, selectedNodes:Array):String {
                const tokens:Array = [chartName || ""];
                for (var i:int = 0; i < selectedNodes.length; i++) {
                    tokens.push(i + '-' + selectedNodes[i][0]);
                }
                return tokens.join(',');
            }
            
            /**
             * Resets all display values to their defaults.
             */
            private function _reset():void {
                _numNodes = 0;
                _currValue = 0;
                _currNodeTime = null;
                _minRangeValue = NaN;
                _maxRangeValue = NaN;
                _avgRangeValue = NaN;
            }
            
            /**
             * Sets all UI visibility flags based on current selection.
             */
            private function _updateUi():void {
                _haveSingleSelection = _numNodes === 1;
                _haveMultipleSelection = _numNodes > 1;
                _haveSelection = _haveSingleSelection || _haveMultipleSelection;
                _haveRange = _haveMultipleSelection &&
                    !isNaN(_minRangeValue) && !isNaN(_maxRangeValue) &&
                    _minRangeValue !== _maxRangeValue;
                _haveEmptyRange = (_haveMultipleSelection && !_haveRange);
                _haveCommonValue = _haveSingleSelection || _haveEmptyRange;
            }
            
            /**
             * Converts, e.g., `0.5` to `50`.
             */
            private function _toPercent(val:Number):int {
                return Math.round(val * 100);
            }
            
            /**
             * Converts, e.g., `50` to `0.5`.
             */
            private function _fromPercent(val:int):Number {
                return val / 100;
            }
            
            /**
             * Analyzes given `nodes` and returns an Object with their
             * minimum, maximum and average values.
             *
             * @param   `nodes`
             *           Assumed valid, non-empty Array of valid doublets.
             *
             * @return  An Object similar to:
             *          {min: 0, max: 0.5, avg: 1}
             */
            private function _analyzeY(nodes:Array):Object {
                var sum:Number = 0;
                var min:Number = Number.MAX_VALUE;
                var max:Number = -Number.MAX_VALUE;
            
                for each (var node:Array in nodes) {
                    var y:Number = node[1];
                    if (y < min) {
                        min = y;
                    }
                    if (y > max) {
                        max = y;
                    }
                    sum += y;
                }
            
                var avg:Number = sum / nodes.length;
                return {min: min, max: max, avg: avg};
            }
            
            /**
             * Formally validates the received `dataProvider`. Expected format is, e.g.:
             * {
             *      "selectedNode":[1,0],
             *      "anchorNode":[1,0],
             *      "selectedNodes":[[0,0.1],[0.5,0.8],[0.95,0],[1,0]]
             * }
             */
            private function _validateDataProvider(dataProvider:Object):Boolean {
                if (!dataProvider) {
                    return false;
                }
                const expectedProps:Array = ['selectedNode', 'anchorNode', 'selectedNodes'];
                for each (var propName:String in expectedProps) {
                    if (!dataProvider.hasOwnProperty(propName)) {
                        return false;
                    }
                    if (!(dataProvider[propName] is Array)) {
                        return false;
                    }
                    if ((dataProvider[propName] as Array).length === 0) {
                        return false;
                    }
            
                    const validatorFn:Function = (propName === 'selectedNodes') ?
                        _validateDoublets : _validateDoublet;
                    if (!validatorFn(dataProvider[propName] as Array)) {
                        return false;
                    }
                }
            
                return true;
            }
            
            /**
             * Validates the given `doublets` Array as an Array of legitimate doublets.
             *
             * @param   doublets
             *          Assumed non-null Array to validate.
             */
            private function _validateDoublets(doublets:Array):Boolean {
                for (var i:int = 0; i < doublets.length; i++) {
                    if (!_validateDoublet(doublets[i])) {
                        return false;
                    }
                }
                return true;
            }
            
            /**
             * Validates the given `doublet` as an Array of exactly two valid
             * numeric values.
             *
             * @param   doublet
             *          Assumed non-null Array to validate.
             */
            private function _validateDoublet(doublet:Array):Boolean {
                return (doublet.length === 2 &&
                        !isNaN(doublet[0]) && !isNaN(doublet[1]));
            }
            
            /**
             * Sets given `value` in all doublets found inside the given `dp`.
             * @param   dp
             *          Either `null` or a previously validated data provider.
             *
             * @param   value
             *          Either `NaN` or a previously validated Number.
             *
             * @param   value
             *          Whether given `value` should be treated as absolute or an offset.
             */
            private function _patchDataProvider(dp:Object, value:Number, offsetMode:Boolean = false):void {
                if (!dp || isNaN(value)) {
                    return;
                }
            
                for (var propName:String in dp) {
                    const dataset:Array = dp[propName] as Array;
                    const patcherFn:Function = (propName === 'selectedNodes') ?
                        _patchDoublets : _patchDoublet;
                    patcherFn(dataset, value, offsetMode);
                }
            }
            
            /**
             * Patches the given `doublets` Array by replacing the second item of
             * each `doublet` with given `value`.
             *
             * @param   doublet
             *          Assumed non-null and validated doublets Array to patch.
             *
             * @param   value
             *          Assumed valid Number to use.
             *
             * @param   offsetMode
             *          optional. If `true`, treats received `value` as an offset.
             */
            private function _patchDoublets(doublets:Array, value:Number, offsetMode:Boolean = false):void {
                for (var i:int = 0; i < doublets.length; i++) {
                    _patchDoublet(doublets[i], value, offsetMode);
                }
            }
            
            /**
             * Patches the given `doublet` by replacing its second item with
             * given `value`.
             *
             * @param   doublet
             *          Assumed non-null and validated doublet Array to patch.
             *
             * @param   value
             *          Assumed valid Number to use.
             *
             * @param   offsetMode
             *          optional. If `true`, treats received `value` as an offset.
             */
            private function _patchDoublet(doublet:Array, value:Number, offsetMode:Boolean = false):void {
                if (offsetMode) {
                    doublet[1] += value;
                }
                else {
                    doublet[1] = value;
                }
            }
            
            /**
             * Sets all selected nodes to given `value`.
             */
            private function _setAllTo(percent:Number):void {
                if (isNaN(percent)) {
                    return;
                }
            
                if (!_dataProvider) {
                    return;
                }
            
                const value:Number = _fromPercent(percent);
                _patchDataProvider(_dataProvider, value);
                dispatchEvent(new NodalEvent(NodalEvent.SELECTION_PATCH, _dataProvider));
            }
            
            /**
             * Delegatee of both `_onNodeValueChanged` and `_onNodesOffsetChanged`;
             * instruments actual data provider patching and associated notification.
             */
            private function _doPatching(event:Event, offsetMode:Boolean = false):void {
                if (!_dataProvider || !event || !event.target) {
                    return;
                }
            
                const ns:NumericStepper = (event.target as NumericStepper);
                if (!ns) {
                    return;
                }
            
                const value:Number = _fromPercent(ns.value);
                if (isNaN(value)) {
                    return;
                }
            
                // Calculate the delta/displacement relative to the last
                // known value.
                if (offsetMode) {
                    const deltaValue:Number = (value - _currOffset);
                    _currOffset = value;
                }
            
                _patchDataProvider(_dataProvider, offsetMode ? deltaValue : value, offsetMode);
                dispatchEvent(new NodalEvent(NodalEvent.SELECTION_PATCH, _dataProvider));
            }
            
            /**
             * Listener. Executes when a single selected node's value has been changed
             * through the "Value" Numeric Stepper component.
             */
            private function _onNodeValueChanged(event:Event):void {
                _doPatching(event);
            }
            
            /**
             * Listener. Executes when several selected node's offset has been changed
             * through the "Offset" Numeric Stepper component.
             */
            private function _onNodesOffsetChanged(event:Event):void {
                _doPatching(event, true);
            }
        ]]>
    </fx:Script>

    <!-- Chart name and number of selected nodes -->
    <s:Label text="Selection:"
        styleName="{getStyle('headerStyle')}"
        width="100%" textAlign="right"/>

    <!-- Shown when there is something selected -->
    <s:Label text="{chartName} ({_numNodes} {(_numNodes === 1)? 'node' : 'nodes'})"
        styleName="{getStyle('bodyStyle')}"
        visible="{_haveSelection}" includeInLayout="{_haveSelection}"/>

    <!-- Shown when there is no selection -->
    <s:Label text="none"
        styleName="{getStyle('bodyStyle')}"
        visible="{!_haveSelection}" includeInLayout="{!_haveSelection}"/>

    <!-- Time (only shown for single selection) -->
    <s:Label text="Time:"
        styleName="{getStyle('headerStyle')}"
        width="100%" textAlign="right"
        visible="{_haveSingleSelection}" includeInLayout="{_haveSingleSelection}"/>

    <s:Label text="{_currNodeTime}"
        styleName="{getStyle('bodyStyle')}"
        visible="{_haveSingleSelection}" includeInLayout="{_haveSingleSelection}"/>

    <!-- Range (only shown for multiple selection) -->
    <s:Label text="Range:" styleName="{getStyle('headerStyle')}"
        width="100%" textAlign="right"
        visible="{_haveMultipleSelection}" includeInLayout="{_haveMultipleSelection}"/>

    <!-- Notice about an empty range -->
    <s:Label text="all same value"
        styleName="{getStyle('bodyStyle')}"
        visible="{_haveEmptyRange}" includeInLayout="{_haveEmptyRange}"/>

    <!-- Range description and utility buttons (only shown for non-empty range) -->
    <s:HGroup padding="0" gap="5" verticalAlign="middle"
        visible="{_haveRange}" includeInLayout="{_haveRange}">

        <s:Label text="{_minRangeValue}% → {_maxRangeValue}% (avg: {_avgRangeValue}%)"
            styleName="{getStyle('bodyStyle')}"/>

        <s:Button label="↓" toolTip="Floor" width="40"
            click="_setAllTo (_minRangeValue)" styleName="{getStyle('buttonStyle')}"/>

        <s:Button label="↑" toolTip="Ceil" width="40"
            click="_setAllTo (_maxRangeValue)" styleName="{getStyle('buttonStyle')}"/>

        <s:Button label="÷" toolTip="Middle" width="40"
            click="_setAllTo (_avgRangeValue)" styleName="{getStyle('buttonStyle')}"/>

    </s:HGroup>

    <!-- Value/Offset reusable label -->
    <s:Label text="{_haveCommonValue? 'Value' : 'Offset'}:"
        styleName="{getStyle('headerStyle')}"
        width="100%" textAlign="right"
        visible="{_haveSelection}"
        includeInLayout="{_haveSelection}"/>

    <!-- Value/Offset reusable container -->
    <s:HGroup padding="0" gap="5" verticalAlign="middle"
        visible="{_haveSelection}"
        includeInLayout="{_haveSelection}">

        <s:NumericStepper id="valueNs"
            value="{_currValue}"
            minimum="0" maximum="100" stepSize="1"
            change="{_onNodeValueChanged (event)}"
            visible="{_haveCommonValue}" includeInLayout="{_haveCommonValue}"/>

        <s:NumericStepper id="offsetNs"
            minimum="{_offsetMin}"
            maximum="{_offsetMax}"
            stepSize="1"
            change="{_onNodesOffsetChanged (event)}"
            visible="{_haveRange}" includeInLayout="{_haveRange}"/>

        <s:Label text="%" styleName="{getStyle('bodyStyle')}"/>
    </s:HGroup>

</s:TileGroup>