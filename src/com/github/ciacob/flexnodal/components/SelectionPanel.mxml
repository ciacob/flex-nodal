<?xml version="1.0" encoding="utf-8"?>
<s:HGroup
    xmlns:fx="http://ns.adobe.com/mxml/2009"
    xmlns:s="library://ns.adobe.com/flex/spark"
    xmlns:mx="library://ns.adobe.com/flex/mx"
    xmlns:spark="mx.skins.spark.*"

    gap="{getStyle ('padding') || 0}"
    minHeight="{getStyle('rowHeight') || 0}"
    horizontalAlign="center"
    verticalAlign="middle"
    width="100%">

    <fx:Metadata>
        [Event(name="selectionPatch", type="com.github.ciacob.flexnodal.events.SelectionEvent")]
        
        [Style(name="headerStyle", type="String", inherit="false")]
        [Style(name="bodyStyle", type="String", inherit="false")]
        [Style(name="buttonStyle", type="String", inherit="false")]
    </fx:Metadata>

    <fx:Script>
        <![CDATA[
            import spark.components.NumericStepper;
            import com.github.ciacob.flexnodal.events.SelectionEvent;
            import com.github.ciacob.flexnodal.events.NodalEvent;
            import com.github.ciacob.flexnodal.utils.Helpers;
            import com.github.ciacob.flexnodal.utils.SelectionDetails;
            import flash.geom.Point;
            
            // The name of the current chart; displayed at the top of the panel.
            [Bindable]
            public var chartName:String;
            
            // Text and/or icon to display inside the "Floor" action button.
            [Bindable]
            public var floorBtnContent:Object = 'Floor';
            
            // Text and/or icon to display inside the "Ceil" action button.
            [Bindable]
            public var ceilBtnContent:Object = 'Ceil';
            
            // Text and/or icon to display inside the "Average" action button.
            [Bindable]
            public var averageBtnContent:Object = 'Average';
            
            // UI visibility flag to raise when there is any selection
            [Bindable]
            private var _haveSelection:Boolean;
            
            // UI visibility flag to raise when we are in single selection scenario.
            [Bindable]
            private var _haveSingleSelection:Boolean;
            
            // UI visibility flag to raise when we are in multiple selection scenario.
            [Bindable]
            private var _haveMultipleSelection:Boolean;
            
            // UI visibility flag to raise when we have a non-empty range (i.e., minimum
            // is not the same as maximum).
            [Bindable]
            private var _haveRange:Boolean;
            
            // UI visibility flag to raise when we have an empty range (i.e., minimum is the
            // same as maximum);
            [Bindable]
            private var _haveEmptyRange:Boolean;
            
            // UI visibility flag to raise when we have either a single selection, or a
            // no-range multiple selection (all selected nodes have the same value).
            [Bindable]
            private var _haveCommonValue:Boolean;
            
            // Storage for the current number of selected nodes.
            [Bindable]
            private var _numNodes:int;
            
            // Storage for the value of the currently selected node (single selection scenario).
            [Bindable]
            private var _currValue:int;
            
            // Storage for the `minimum` property to pass to the "Offset" Numeric Stepper component.
            [Bindable]
            private var _offsetMin:int;
            
            // Storage for the `maximum` property to pass to the "Offset" Numeric Stepper component.
            [Bindable]
            private var _offsetMax:int;
            
            // Storage for the time of the currently selected node (single selection scenario).
            [Bindable]
            private var _currNodeTime:String;
            
            // Storage for the minimum of all selected values (multiple selection scenario).
            [Bindable]
            private var _minRangeValue:Number;
            
            // Storage for the maximum of all selected values (multiple selection scenario).
            [Bindable]
            private var _maxRangeValue:Number;
            
            // Storage for the average of all selected values (multiple selection scenario).
            [Bindable]
            private var _avgRangeValue:Number;
            
            // Storage for the last known offset applied to selected nodes (multiple
            // selection scenario).
            private var _currOffset:Number = 0;
            
            // Storage for the last known selection hash. Used to determine if selection
            // has been changed outside the SelectionPanel component.
            private var _selectionHash:String;
            
            // ---------------------------
            // The `dataProvider` property
            // ---------------------------
            
            // Internal storage for the `dataProvider` property
            private var _dataProvider:SelectionDetails;
            
            // Flag we raise when the `dataProvider` property has been externally changed
            private var _dataProviderChanged:Boolean;
            
            /**
             * Returns the current data provider of this component. Reflects internal
             * changes.
             */
            public function get dataProvider():SelectionDetails {
                return _dataProvider;
            }
            
            /**
             * Sets or replaces a data provider for this component.
             * @param   value
             *          Immutable selection details describing the current context.
             */
            public function set dataProvider(value:SelectionDetails):void {
                if (value !== _dataProvider) {
                    _dataProvider = value;
                    _dataProviderChanged = true;
                    invalidateProperties();
                }
            }
            
            /**
             * Rebuilds this component’s internal representation
             * of the current selection context. This can help
             * address edge cases, such as undetected manual
             * overlapping selection edits.
             */
            public function reset():void {
                _selectionHash = null;
                _dataProviderChanged = true;
                invalidateProperties();
            }
            
            /**
             * Overridden to handle setting/replacing the data provider.
             */
            override protected function commitProperties():void {
                super.commitProperties();
            
                // Data provider
                if (_dataProviderChanged) {
                    _dataProviderChanged = false;
                    _clearCache();
                    if (_dataProvider) {
                        _numNodes = _dataProvider.selectedValues.length;
                        if (_numNodes) {

                            // Common to single and multiple selection scenarios
                            const selectedNode:Point = _dataProvider.selectedValue;
                            _currValue = Helpers.toPercent(selectedNode.y);
                            _currNodeTime = (Helpers.timeToLabel !== null) ?
                                Helpers.timeToLabel(selectedNode.x) : "";

                            // Multiple selection scenario
                            if (_numNodes > 1) {
                                const stats:Object = Helpers.analyzeY(_dataProvider.selectedValues);
                                _minRangeValue = Helpers.toPercent(stats.min);
                                _maxRangeValue = Helpers.toPercent(stats.max);
                                _avgRangeValue = Helpers.toPercent(stats.avg);

                                const hash:String = _hashSelectionContext(chartName, _dataProvider.selectedValues);
                                if (hash !== _selectionHash) {
                                    _selectionHash = hash;
                                    _offsetMin = Helpers.toPercent(-stats.min);
                                    _offsetMax = Helpers.toPercent(1 - stats.max);
                                    _currOffset = 0;
                                    offsetNs.value = 0;
                                }
                            }
                        }
                    }
                    _updateUi();
                }
            }
            
            /**
             * Creates a unique, deterministic representation of the current selection,
             * based on given `chartName` and `selectedNodes`. Relies on the fact that
             * selected nodes maintain their indices and "y" values when patched.
             */
            private function _hashSelectionContext(chartName:String, selectedNodes:Vector.<Point>):String {
                const tokens:Array = [chartName || ""];
                for (var i:int = 0; i < selectedNodes.length; i++) {
                    tokens.push(i + '-' + selectedNodes[i].x);
                }
                return tokens.join(',');
            }
            
            /**
             * Resets computed values to their defaults.
             */
            private function _clearCache():void {
                _numNodes = 0;
                _currValue = 0;
                _currNodeTime = null;
                _minRangeValue = NaN;
                _maxRangeValue = NaN;
                _avgRangeValue = NaN;
            }
            
            /**
             * Sets all UI visibility flags based on current selection.
             */
            private function _updateUi():void {
                _haveSingleSelection = _numNodes === 1;
                _haveMultipleSelection = _numNodes > 1;
                _haveSelection = _haveSingleSelection || _haveMultipleSelection;
                _haveRange = _haveMultipleSelection &&
                    !isNaN(_minRangeValue) && !isNaN(_maxRangeValue) &&
                    _minRangeValue !== _maxRangeValue;
                _haveEmptyRange = (_haveMultipleSelection && !_haveRange);
                _haveCommonValue = _haveSingleSelection || _haveEmptyRange;
            }
            
            /**
             * Creates a new SelectionDetails instance by applying `value` (or an offset)
             * to all Y coordinates found in the provided selection.
             */
            private function _patchDataProvider(dp:SelectionDetails, value:Number, offsetMode:Boolean = false):SelectionDetails {
                if (!dp || isNaN(value)) {
                    return dp;
                }

                var patchedValues:Vector.<Point> = new <Point>[];
                for each (var p:Point in dp.selectedValues) {
                    patchedValues.push(_patchPoint(p, value, offsetMode));
                }

                var selectedValue:Point = _patchPoint(dp.selectedValue, value, offsetMode);
                var anchor:Point = _patchPoint(dp.selectionAnchor, value, offsetMode);

                _dataProviderChanged = true;
                invalidateProperties();
                return new SelectionDetails(selectedValue, patchedValues, anchor);
            }

            private function _patchPoint(src:Point, value:Number, offsetMode:Boolean = false):Point {
                if (!src) {
                    return null;
                }
                var y:Number = offsetMode ? src.y + value : value;
                y = Math.max(0, Math.min(1, y));
                return new Point(src.x, y);
            }
            
            /**
             * Sets all selected nodes to given `value`.
             */
            private function _setAllTo(percent:Number):void {
                if (isNaN(percent)) {
                    return;
                }
            
                if (!_dataProvider) {
                    return;
                }
            
                const value:Number = Helpers.fromPercent(percent);
                _dataProvider = _patchDataProvider(_dataProvider, value);
                dispatchEvent(new SelectionEvent(NodalEvent.SELECTION_PATCH, chartName, _dataProvider));
            }
            
            /**
             * Delegatee of both `_onNodeValueChanged` and `_onNodesOffsetChanged`;
             * instruments actual data provider patching and associated notification.
             */
            private function _doPatching(event:Event, offsetMode:Boolean = false):void {
                if (!_dataProvider || !event || !event.target) {
                    return;
                }
            
                const ns:NumericStepper = (event.target as NumericStepper);
                if (!ns) {
                    return;
                }
            
                const value:Number = Helpers.fromPercent(ns.value);
                if (isNaN(value)) {
                    return;
                }
            
                // Calculate the delta/displacement relative to the last
                // known value.
                var deltaValue:Number = value;
                if (offsetMode) {
                    deltaValue = (value - _currOffset);
                    _currOffset = value;
                }

                _dataProvider = _patchDataProvider(_dataProvider, offsetMode ? deltaValue : value, offsetMode);
                dispatchEvent(new SelectionEvent(NodalEvent.SELECTION_PATCH, chartName, _dataProvider));
            }
            
            /**
             * Listener. Executes when a single selected node's value has been changed
             * through the "Value" Numeric Stepper component.
             */
            private function _onNodeValueChanged(event:Event):void {
                _doPatching(event);
            }
            
            /**
             * Listener. Executes when several selected node's offset has been changed
             * through the "Offset" Numeric Stepper component.
             */
            private function _onNodesOffsetChanged(event:Event):void {
                _doPatching(event, true);
            }
        ]]>
    </fx:Script>

    <!-- CELL: What is selected -->
    <s:HGroup padding="0" verticalAlign="middle"
        minHeight="{getStyle('rowHeight') || 0}"
        gap="{getStyle('horizontalGap') || 0}"
        width="100%">

        <!-- Chart name and number of selected nodes -->
        <s:Label text="Selection:"
            styleName="{getStyle('headerStyle')}"/>

        <!-- Shown when there is something selected -->
        <s:Label text="{chartName} ({_numNodes} {_haveSingleSelection? 'node' : 'nodes'})"
            width="100%"
            styleName="{getStyle('bodyStyle')}"
            visible="{_haveSelection}" includeInLayout="{_haveSelection}"
            maxDisplayedLines="1"
            showTruncationTip="true" />

        <!-- Shown when there is no selection -->
        <s:Label text="none"
            styleName="{getStyle('bodyStyle')}"
            visible="{!_haveSelection}" includeInLayout="{!_haveSelection}"/>
    </s:HGroup>

    <!-- CELL: Selection time -->
    <s:HGroup padding="0" verticalAlign="middle"
        minHeight="{getStyle('rowHeight') || 0}"
        visible="{_haveSingleSelection}"
        includeInLayout="{_haveSingleSelection}"
        gap="{getStyle('horizontalGap') || 0}">

        <!-- Time (only shown for single selection) -->
        <s:Label text="Time:"
            styleName="{getStyle('headerStyle')}"
            visible="{_haveSingleSelection}" includeInLayout="{_haveSingleSelection}"/>

        <s:Label text="{_currNodeTime}"
            styleName="{getStyle('bodyStyle')}"
            visible="{_haveSingleSelection}" includeInLayout="{_haveSingleSelection}"/>
    </s:HGroup>

    <!-- CELL: Multiple selection (info & tools) -->
    <s:HGroup padding="0" verticalAlign="middle"
        minHeight="{getStyle('rowHeight') || 0}"
        visible="{_haveMultipleSelection}"
        includeInLayout="{_haveMultipleSelection}"
        gap="{getStyle('horizontalGap') || 0}">

        <!-- Range (only shown for multiple selection) -->
        <s:Label text="Range:" styleName="{getStyle('headerStyle')}"
            visible="{_haveMultipleSelection}" includeInLayout="{_haveMultipleSelection}"/>

        <!-- Notice about an empty range -->
        <s:Label text="all same value"
            styleName="{getStyle('bodyStyle')}"
            visible="{_haveEmptyRange}" includeInLayout="{_haveEmptyRange}"/>

        <!-- Range description and utility buttons (only shown for non-empty range) -->
        <s:HGroup padding="0" verticalAlign="middle"
            gap="{getStyle('horizontalGap') || 0}"
            minHeight="{getStyle('rowHeight') || 0}"
            visible="{_haveRange}" includeInLayout="{_haveRange}">

            <s:Label text="{_minRangeValue}% → {_maxRangeValue}% (avg: {_avgRangeValue}%)"
                styleName="{getStyle('bodyStyle')}"/>

            <s:Button content="{floorBtnContent}" toolTip="Set all to lowest"
                click="_setAllTo (_minRangeValue)" styleName="{getStyle('buttonStyle')}"/>

            <s:Button content="{ceilBtnContent}" toolTip="Set all to highest"
                click="_setAllTo (_maxRangeValue)" styleName="{getStyle('buttonStyle')}"/>

            <s:Button content="{averageBtnContent}" toolTip="Set all to average"
                click="_setAllTo (_avgRangeValue)" styleName="{getStyle('buttonStyle')}"/>

        </s:HGroup>
    </s:HGroup>

    <!-- CELL: Single/Common value/Offset (info & tools) -->
    <s:HGroup padding="0" verticalAlign="middle"
        minHeight="{getStyle('rowHeight') || 0}"
        visible="{_haveSelection}"
        includeInLayout="{_haveSelection}"
        gap="{getStyle('horizontalGap') || 0}">

        <!-- Value/Offset reusable label -->
        <s:Label text="{_haveCommonValue? 'Value' : 'Offset'}:"
            styleName="{getStyle('headerStyle')}"
            visible="{_haveSelection}"
            includeInLayout="{_haveSelection}"/>

        <!-- Value/Offset reusable container -->
        <s:HGroup padding="0"
            minHeight="{getStyle('rowHeight') || 0}"
            gap="{getStyle('horizontalGap') || 0}"
            verticalAlign="middle"
            visible="{_haveSelection}"
            includeInLayout="{_haveSelection}">

            <s:NumericStepper id="valueNs"
                value="{_currValue}"
                minimum="0" maximum="100" stepSize="1"
                change="{_onNodeValueChanged (event)}"
                visible="{_haveCommonValue}" includeInLayout="{_haveCommonValue}"/>

            <s:NumericStepper id="offsetNs"
                minimum="{_offsetMin}"
                maximum="{_offsetMax}"
                stepSize="1"
                change="{_onNodesOffsetChanged (event)}"
                visible="{_haveRange}" includeInLayout="{_haveRange}"/>

            <s:Label text="%" styleName="{getStyle('bodyStyle')}"/>
        </s:HGroup>
    </s:HGroup>

</s:HGroup>